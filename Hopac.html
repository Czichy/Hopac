<!DOCTYPE html>
<html>
<head>
<title>Hopac Library Reference</title>
<style>
pre {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 5px;
line-height: 160%;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
code {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 2px;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
div.nested {
padding-left: 1.5em;
}
a {
text-decoration: none;
font-weight: bold;
}
</style>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Hopac Library Reference</h1>
<p>This document provides a reference manual for the Hopac library and is generated from the library source code.</p>
<h2>Synopsis</h2>
<pre><b>namespace</b> <a id="dec:namespace Hopac" href="#def:namespace Hopac">Hopac</a></pre>
<pre><b>type</b> <a id="dec:type Hopac.BoundedMb" href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.BoundedMb" href="#def:module Hopac.BoundedMb">BoundedMb</a> <b>=</b>
  <b>val</b> <a id="dec:val Hopac.BoundedMb.create" href="#def:val Hopac.BoundedMb.create">create</a><b>:</b> capacity<b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.BoundedMb.put" href="#def:val Hopac.BoundedMb.put">put</a><b>:</b> <a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.BoundedMb.take" href="#def:val Hopac.BoundedMb.take">take</a><b>:</b> <a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Void" href="#def:type Hopac.Void">Void</a>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.IAsyncDisposable" href="#def:type Hopac.IAsyncDisposable">IAsyncDisposable</a> <b>=</b>
  <b>abstract</b> <a id="dec:abstract Hopac.IAsyncDisposable.DisposeAsync" href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.JobBuilder" href="#def:type Hopac.JobBuilder">JobBuilder</a> <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
  <b>member</b> Bind<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i>   <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i>   <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a>     <b>*</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i>   <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a>       <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> For<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a>     <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryFinally<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryFinally<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryFinally<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a>     <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> TryFinally<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryWith<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>  ) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryWith<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>  ) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryWith<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a>     <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> TryWith<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>  ) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Using<b>:</b> <i>'x</i> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
  <b>member</b> While<b>:</b> (unit <b>-&gt;</b> bool) <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.EmbeddedJob" href="#def:type Hopac.EmbeddedJob">EmbeddedJob</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <b>struct</b>
    <b>val</b> <a href="#def:type Hopac.Job">Job</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>new</b><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.EmbeddedJob">EmbeddedJob</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>end</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.EmbeddedJobBuilder" href="#def:type Hopac.EmbeddedJobBuilder">EmbeddedJobBuilder</a> <b>=</b>
  inherit <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.EmbeddedJobBuilder">EmbeddedJobBuilder</a>
  <b>member</b> Run<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.EmbeddedJob">EmbeddedJob</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Proc" href="#def:type Hopac.Proc">Proc</a> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Proc" href="#def:module Hopac.Proc">Proc</a> <b>=</b>
  <b>val</b> <a id="dec:val Hopac.Proc.start" href="#def:val Hopac.Proc.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Proc.startIgnore" href="#def:val Hopac.Proc.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Proc.queue" href="#def:val Hopac.Proc.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Proc.queueIgnore" href="#def:val Hopac.Proc.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Proc.self" href="#def:val Hopac.Proc.self">self</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Proc.join" href="#def:val Hopac.Proc.join">join</a><b>:</b> <a href="#def:type Hopac.Proc">Proc</a> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Job" href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Job" href="#def:module Hopac.Job">Job</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Job.Global" href="#def:module Hopac.Job.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Job.Global.startWithActions" href="#def:val Hopac.Job.Global.startWithActions">startWithActions</a><b>:</b> (exn <b>-&gt;</b> unit) <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.start" href="#def:val Hopac.Job.Global.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.startIgnore" href="#def:val Hopac.Job.Global.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.queue" href="#def:val Hopac.Job.Global.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.queueIgnore" href="#def:val Hopac.Job.Global.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.server" href="#def:val Hopac.Job.Global.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.run" href="#def:val Hopac.Job.Global.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
  <b>val</b> <a id="dec:val Hopac.Job.start" href="#def:val Hopac.Job.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.startIgnore" href="#def:val Hopac.Job.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.queue" href="#def:val Hopac.Job.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.queueIgnore" href="#def:val Hopac.Job.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.server" href="#def:val Hopac.Job.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.startWithFinalizer" href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a><b>:</b> finalizer<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.startWithFinalizerIgnore" href="#def:val Hopac.Job.startWithFinalizerIgnore">startWithFinalizerIgnore</a><b>:</b> finalizer<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.delay" href="#def:val Hopac.Job.delay">delay</a><b>:</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.delayWith" href="#def:val Hopac.Job.delayWith">delayWith</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.lift" href="#def:val Hopac.Job.lift">lift</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.thunk" href="#def:val Hopac.Job.thunk">thunk</a><b>:</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.Ignore" href="#def:val Hopac.Job.Ignore">Ignore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.unit" href="#def:val Hopac.Job.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.result" href="#def:val Hopac.Job.result">result</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.bind" href="#def:val Hopac.Job.bind">bind</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.join" href="#def:val Hopac.Job.join">join</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.map" href="#def:val Hopac.Job.map">map</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.abort" href="#def:val Hopac.Job.abort">abort</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.raises" href="#def:val Hopac.Job.raises">raises</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Job.Infixes" href="#def:module Hopac.Job.Infixes">Infixes</a> <b>=</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;=" href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;." href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes..&gt;&gt;" href="#def:val Hopac.Job.Infixes..&gt;&gt;">.&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.|&gt;&gt;" href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;%" href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;!" href="#def:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&lt;&amp;&gt;" href="#def:val Hopac.Job.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&lt;*&gt;" href="#def:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryIn" href="#def:val Hopac.Job.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryWith" href="#def:val Hopac.Job.tryWith">tryWith</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryFinallyFun" href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryFinallyJob" href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.using" href="#def:val Hopac.Job.using">using</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
  <b>val</b> <a id="dec:val Hopac.Job.usingAsync" href="#def:val Hopac.Job.usingAsync">usingAsync</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> <a href="#def:type Hopac.IAsyncDisposable">IAsyncDisposable</a>
  <b>val</b> <a id="dec:val Hopac.Job.catch" href="#def:val Hopac.Job.catch">catch</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Choice<b>&lt;</b><i>'x</i>, exn<b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forN" href="#def:val Hopac.Job.forN">forN</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forNIgnore" href="#def:val Hopac.Job.forNIgnore">forNIgnore</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forUpTo" href="#def:val Hopac.Job.forUpTo">forUpTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forUpToIgnore" href="#def:val Hopac.Job.forUpToIgnore">forUpToIgnore</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forDownTo" href="#def:val Hopac.Job.forDownTo">forDownTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forDownToIgnore" href="#def:val Hopac.Job.forDownToIgnore">forDownToIgnore</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.whileDo" href="#def:val Hopac.Job.whileDo">whileDo</a><b>:</b> (unit <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.whileDoIgnore" href="#def:val Hopac.Job.whileDoIgnore">whileDoIgnore</a><b>:</b> (unit <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.whenDo" href="#def:val Hopac.Job.whenDo">whenDo</a><b>:</b> bool <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forever" href="#def:val Hopac.Job.forever">forever</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.foreverIgnore" href="#def:val Hopac.Job.foreverIgnore">foreverIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.iterate" href="#def:val Hopac.Job.iterate">iterate</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.foreverServer" href="#def:val Hopac.Job.foreverServer">foreverServer</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.iterateServer" href="#def:val Hopac.Job.iterateServer">iterateServer</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.seqCollect" href="#def:val Hopac.Job.seqCollect">seqCollect</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.seqIgnore" href="#def:val Hopac.Job.seqIgnore">seqIgnore</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.conCollect" href="#def:val Hopac.Job.conCollect">conCollect</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.conIgnore" href="#def:val Hopac.Job.conIgnore">conIgnore</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.fromBeginEnd" href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a><b>:</b> (AsyncCallback <b>*</b> obj <b>-&gt;</b> IAsyncResult)
                 <b>-&gt;</b> (IAsyncResult <b>-&gt;</b> <i>'x</i>)
                 <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.fromEndBegin" href="#def:val Hopac.Job.fromEndBegin">fromEndBegin</a><b>:</b> (IAsyncResult <b>-&gt;</b> <i>'x</i>)
                 <b>-&gt;</b> (AsyncCallback <b>*</b> obj <b>-&gt;</b> IAsyncResult)
                 <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.scheduler" href="#def:val Hopac.Job.scheduler">scheduler</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Scheduler">Scheduler</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.switchToWorker" href="#def:val Hopac.Job.switchToWorker">switchToWorker</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.paranoid" href="#def:val Hopac.Job.paranoid">paranoid</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Job.Random" href="#def:module Hopac.Job.Random">Random</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Job.Random.bind" href="#def:val Hopac.Job.Random.bind">bind</a><b>:</b> (uint64 <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Job.Random.map" href="#def:val Hopac.Job.Random.map">map</a><b>:</b> (uint64 <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Job.Random.get" href="#def:val Hopac.Job.Random.get">get</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>uint64<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Alt" href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Alt" href="#def:module Hopac.Alt">Alt</a> <b>=</b>
  <b>val</b> <a id="dec:val Hopac.Alt.always" href="#def:val Hopac.Alt.always">always</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.unit" href="#def:val Hopac.Alt.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.never" href="#def:val Hopac.Alt.never">never</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.zero" href="#def:val Hopac.Alt.zero">zero</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.once" href="#def:val Hopac.Alt.once">once</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.raises" href="#def:val Hopac.Alt.raises">raises</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.guard" href="#def:val Hopac.Alt.guard">guard</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.delay" href="#def:val Hopac.Alt.delay">delay</a><b>:</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.random" href="#def:val Hopac.Alt.random">random</a><b>:</b> (uint64 <b>-&gt;</b> #<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.withNack" href="#def:val Hopac.Alt.withNack">withNack</a><b>:</b> (<a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.wrapAbort" href="#def:val Hopac.Alt.wrapAbort">wrapAbort</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.choose" href="#def:val Hopac.Alt.choose">choose</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.chooser" href="#def:val Hopac.Alt.chooser">chooser</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.wrap" href="#def:val Hopac.Alt.wrap">wrap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.map" href="#def:val Hopac.Alt.map">map</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.Ignore" href="#def:val Hopac.Alt.Ignore">Ignore</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Alt.Infixes" href="#def:module Hopac.Alt.Infixes">Infixes</a> <b>=</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&lt;|&gt;?" href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&lt;~&gt;?" href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;=?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;.?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;.?">&gt;&gt;.?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes..&gt;&gt;?" href="#def:val Hopac.Alt.Infixes..&gt;&gt;?">.&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.|&gt;&gt;?" href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;%?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;!?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;!?">&gt;&gt;!?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&lt;+&gt;?" href="#def:val Hopac.Alt.Infixes.&lt;+&gt;?">&lt;+&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'a</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'b</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'a</i> <b>*</b> <i>'b</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.tryIn" href="#def:val Hopac.Alt.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.tryFinallyFun" href="#def:val Hopac.Alt.tryFinallyFun">tryFinallyFun</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.tryFinallyJob" href="#def:val Hopac.Alt.tryFinallyJob">tryFinallyJob</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.paranoid" href="#def:val Hopac.Alt.paranoid">paranoid</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Timer" href="#def:module Hopac.Timer">Timer</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Timer.Global" href="#def:module Hopac.Timer.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Timer.Global.timeOut" href="#def:val Hopac.Timer.Global.timeOut">timeOut</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Timer.Global.timeOutMillis" href="#def:val Hopac.Timer.Global.timeOutMillis">timeOutMillis</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Ch" href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Ch" href="#def:module Hopac.Ch">Ch</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Ch.Now" href="#def:module Hopac.Ch.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Now.create" href="#def:val Hopac.Ch.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Ch.Global" href="#def:module Hopac.Ch.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Global.send" href="#def:val Hopac.Ch.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Ch.create" href="#def:val Hopac.Ch.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Ch.give" href="#def:val Hopac.Ch.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Ch.take" href="#def:val Hopac.Ch.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Ch.send" href="#def:val Hopac.Ch.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Ch.Try" href="#def:module Hopac.Ch.Try">Try</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Try.give" href="#def:val Hopac.Ch.Try.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>bool<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Try.take" href="#def:val Hopac.Ch.Try.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>option<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.IVar" href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.IVar" href="#def:module Hopac.IVar">IVar</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.IVar.Now" href="#def:module Hopac.IVar.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.IVar.Now.create" href="#def:val Hopac.IVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.IVar.Now.createFull" href="#def:val Hopac.IVar.Now.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.IVar.Now.createFailure" href="#def:val Hopac.IVar.Now.createFailure">createFailure</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.IVar.Now.isFull" href="#def:val Hopac.IVar.Now.isFull">isFull</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> bool
    <b>val</b> <a id="dec:val Hopac.IVar.Now.get" href="#def:val Hopac.IVar.Now.get">get</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
  <b>val</b> <a id="dec:val Hopac.IVar.create" href="#def:val Hopac.IVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.fill" href="#def:val Hopac.IVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.tryFill" href="#def:val Hopac.IVar.tryFill">tryFill</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.fillFailure" href="#def:val Hopac.IVar.fillFailure">fillFailure</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.read" href="#def:val Hopac.IVar.read">read</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Latch" href="#def:type Hopac.Latch">Latch</a> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Latch" href="#def:module Hopac.Latch">Latch</a> <b>=</b>
  <b>val</b> <a id="dec:val Hopac.Latch.within" href="#def:val Hopac.Latch.within">within</a><b>:</b> (<a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Latch.holding" href="#def:val Hopac.Latch.holding">holding</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Latch.queue" href="#def:val Hopac.Latch.queue">queue</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Latch.queueAsPromise" href="#def:val Hopac.Latch.queueAsPromise">queueAsPromise</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Latch.Now" href="#def:module Hopac.Latch.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Latch.Now.create" href="#def:val Hopac.Latch.Now.create">create</a><b>:</b> initial<b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Latch">Latch</a>
    <b>val</b> <a id="dec:val Hopac.Latch.Now.increment" href="#def:val Hopac.Latch.Now.increment">increment</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Latch.decrement" href="#def:val Hopac.Latch.decrement">decrement</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Latch.await" href="#def:val Hopac.Latch.await">await</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.MVar" href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.MVar" href="#def:module Hopac.MVar">MVar</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.MVar.Now" href="#def:module Hopac.MVar.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.MVar.Now.create" href="#def:val Hopac.MVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.MVar.Now.createFull" href="#def:val Hopac.MVar.Now.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.create" href="#def:val Hopac.MVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.createFull" href="#def:val Hopac.MVar.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.fill" href="#def:val Hopac.MVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.modifyFun" href="#def:val Hopac.MVar.modifyFun">modifyFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>*</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.modifyJob" href="#def:val Hopac.MVar.modifyJob">modifyJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.read" href="#def:val Hopac.MVar.read">read</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.take" href="#def:val Hopac.MVar.take">take</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Mailbox" href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Mailbox" href="#def:module Hopac.Mailbox">Mailbox</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Mailbox.Now" href="#def:module Hopac.Mailbox.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Mailbox.Now.create" href="#def:val Hopac.Mailbox.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Mailbox.Global" href="#def:module Hopac.Mailbox.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Mailbox.Global.send" href="#def:val Hopac.Mailbox.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Mailbox.create" href="#def:val Hopac.Mailbox.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Mailbox.send" href="#def:val Hopac.Mailbox.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Mailbox.take" href="#def:val Hopac.Mailbox.take">take</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Promise" href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Promise" href="#def:module Hopac.Promise">Promise</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Promise.Now" href="#def:module Hopac.Promise.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.delay" href="#def:val Hopac.Promise.Now.delay">delay</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.withValue" href="#def:val Hopac.Promise.Now.withValue">withValue</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.withFailure" href="#def:val Hopac.Promise.Now.withFailure">withFailure</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.isFulfilled" href="#def:val Hopac.Promise.Now.isFulfilled">isFulfilled</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> bool
    <b>val</b> <a id="dec:val Hopac.Promise.Now.get" href="#def:val Hopac.Promise.Now.get">get</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
  <b>module</b> <a id="dec:module Hopac.Promise.Infixes" href="#def:module Hopac.Promise.Infixes">Infixes</a> <b>=</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes.&lt;|&gt;*" href="#def:val Hopac.Promise.Infixes.&lt;|&gt;*">&lt;|&gt;*</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes.&gt;&gt;=*" href="#def:val Hopac.Promise.Infixes.&gt;&gt;=*">&gt;&gt;=*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes.&gt;&gt;.*" href="#def:val Hopac.Promise.Infixes.&gt;&gt;.*">&gt;&gt;.*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes..&gt;&gt;*" href="#def:val Hopac.Promise.Infixes..&gt;&gt;*">.&gt;&gt;*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes.|&gt;&gt;*" href="#def:val Hopac.Promise.Infixes.|&gt;&gt;*">|&gt;&gt;*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes.&gt;&gt;%*" href="#def:val Hopac.Promise.Infixes.&gt;&gt;%*">&gt;&gt;%*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Promise.Infixes.&gt;&gt;!*" href="#def:val Hopac.Promise.Infixes.&gt;&gt;!*">&gt;&gt;!*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Promise.start" href="#def:val Hopac.Promise.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Promise.queue" href="#def:val Hopac.Promise.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Promise.read" href="#def:val Hopac.Promise.read">read</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Lock" href="#def:type Hopac.Lock">Lock</a>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Lock" href="#def:module Hopac.Lock">Lock</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Lock.Now" href="#def:module Hopac.Lock.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Lock.Now.create" href="#def:val Hopac.Lock.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Lock">Lock</a>
  <b>val</b> <a id="dec:val Hopac.Lock.create" href="#def:val Hopac.Lock.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Lock">Lock</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Lock.duringFun" href="#def:val Hopac.Lock.duringFun">duringFun</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Lock.duringJob" href="#def:val Hopac.Lock.duringJob">duringJob</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Extensions" href="#def:module Hopac.Extensions">Extensions</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Extensions.Array" href="#def:module Hopac.Extensions.Array">Array</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Array.mapJob" href="#def:val Hopac.Extensions.Array.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>array<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Array.iterJob" href="#def:val Hopac.Extensions.Array.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Array.iterJobIgnore" href="#def:val Hopac.Extensions.Array.iterJobIgnore">iterJobIgnore</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Extensions.Seq" href="#def:module Hopac.Extensions.Seq">Seq</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.iterJob" href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.iterJobIgnore" href="#def:val Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.mapJob" href="#def:val Hopac.Extensions.Seq.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.foldJob" href="#def:val Hopac.Extensions.Seq.foldJob">foldJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> seq<b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>module</b> <a id="dec:module Hopac.Extensions.Seq.Con" href="#def:module Hopac.Extensions.Seq.Con">Con</a> <b>=</b>
      <b>val</b> <a id="dec:val Hopac.Extensions.Seq.Con.iterJob" href="#def:val Hopac.Extensions.Seq.Con.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
      <b>val</b> <a id="dec:val Hopac.Extensions.Seq.Con.iterJobIgnore" href="#def:val Hopac.Extensions.Seq.Con.iterJobIgnore">iterJobIgnore</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
      <b>val</b> <a id="dec:val Hopac.Extensions.Seq.Con.mapJob" href="#def:val Hopac.Extensions.Seq.Con.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Extensions.Async" href="#def:module Hopac.Extensions.Async">Async</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Async.toJob" href="#def:val Hopac.Extensions.Async.toJob">toJob</a><b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Async.toJobOn" href="#def:val Hopac.Extensions.Async.toJobOn">toJobOn</a><b>:</b> SynchronizationContext <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Async.toAlt" href="#def:val Hopac.Extensions.Async.toAlt">toAlt</a><b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Async.toAltOn" href="#def:val Hopac.Extensions.Async.toAltOn">toAltOn</a><b>:</b> SynchronizationContext <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Async.ofJobOn" href="#def:val Hopac.Extensions.Async.ofJobOn">ofJobOn</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>module</b> <a id="dec:module Hopac.Extensions.Async.Global" href="#def:module Hopac.Extensions.Async.Global">Global</a> <b>=</b>
      <b>val</b> <a id="dec:val Hopac.Extensions.Async.Global.ofJob" href="#def:val Hopac.Extensions.Async.Global.ofJob">ofJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>type</b> <a id="dec:type Hopac.Extensions.Async.OnWithSchedulerBuilder" href="#def:type Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a> <b>=</b>
      <b>new</b><b>:</b> SynchronizationContext <b>*</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
      <b>val</b> <a href="#def:type Hopac.Scheduler">Scheduler</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
      <b>val</b> Context<b>:</b> SynchronizationContext
      <b>member</b> Bind<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>
      <b>member</b> Bind<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>
      <b>member</b> Bind<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>
      <b>member</b> Combine<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> Combine<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> Combine<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> For<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b>
      <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> ReturnFrom<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> ReturnFrom<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> ReturnFrom<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> TryFinally<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> TryFinally<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> TryFinally<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> TryWith<b>:</b>  <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> TryWith<b>:</b>   <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> TryWith<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
      <b>member</b> Using<b>:</b> <i>'x</i> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
      <b>member</b> While<b>:</b> (unit <b>-&gt;</b> bool) <b>*</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b>
      <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b>unit<b>&gt;</b>
      <b>member</b> Run<b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Extensions.asyncOn" href="#def:val Hopac.Extensions.asyncOn">asyncOn</a><b>:</b> SynchronizationContext
            <b>-&gt;</b> Scheduler
            <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>.</b><a href="#def:type Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
  <b>type</b> <a id="dec:type Hopac.Extensions.Task" href="#def:type Hopac.Extensions.Task">Task</a> <b>with</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.awaitJob" href="#def:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.awaitJob" href="#def:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.bindJob" href="#def:static member Hopac.Extensions.Task.bindJob">bindJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.bindJob" href="#def:static member Hopac.Extensions.Task.bindJob">bindJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a> <b>*</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.startJob" href="#def:static member Hopac.Extensions.Task.startJob">startJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Scheduler" href="#def:type Hopac.Scheduler">Scheduler</a>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Scheduler" href="#def:module Hopac.Scheduler">Scheduler</a> <b>=</b>
  <b>type</b> <a id="dec:type Hopac.Scheduler.Create" href="#def:type Hopac.Scheduler.Create">Create</a> <b>=</b>
    {
      <a id="dec:field Hopac.Scheduler.Create.Foreground" href="#def:field Hopac.Scheduler.Create.Foreground">Foreground</a><b>:</b> option<b>&lt;</b>bool<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.IdleHandler" href="#def:field Hopac.Scheduler.Create.IdleHandler">IdleHandler</a><b>:</b> option<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>int<b>&gt;&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.MaxStackSize" href="#def:field Hopac.Scheduler.Create.MaxStackSize">MaxStackSize</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.NumWorkers" href="#def:field Hopac.Scheduler.Create.NumWorkers">NumWorkers</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.TopLevelHandler" href="#def:field Hopac.Scheduler.Create.TopLevelHandler">TopLevelHandler</a><b>:</b> option<b>&lt;</b>exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b>
    }
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Scheduler.Create.Def" href="#def:static member Hopac.Scheduler.Create.Def">Def</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a>
  <b>module</b> <a id="dec:module Hopac.Scheduler.Global" href="#def:module Hopac.Scheduler.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Scheduler.Global.setCreate" href="#def:val Hopac.Scheduler.Global.setCreate">setCreate</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.create" href="#def:val Hopac.Scheduler.create">create</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a> <b>-&gt;</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
  <b>val</b> <a id="dec:val Hopac.Scheduler.startWithActions" href="#def:val Hopac.Scheduler.startWithActions">startWithActions</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
                     <b>-&gt;</b> (exn <b>-&gt;</b> unit)
                     <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit)
                     <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.start" href="#def:val Hopac.Scheduler.start">start</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.startIgnore" href="#def:val Hopac.Scheduler.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.queue" href="#def:val Hopac.Scheduler.queue">queue</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.queueIgnore" href="#def:val Hopac.Scheduler.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.server" href="#def:val Hopac.Scheduler.server">server</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.wait" href="#def:val Hopac.Scheduler.wait">wait</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.kill" href="#def:val Hopac.Scheduler.kill">kill</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Infixes" href="#def:module Hopac.Infixes">Infixes</a> <b>=</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;--" href="#def:val Hopac.Infixes.&lt;--">&lt;--</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-+" href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-=" href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-=!" href="#def:val Hopac.Infixes.&lt;-=!">&lt;-=!</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;&lt;-=" href="#def:val Hopac.Infixes.&lt;&lt;-=">&lt;&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;&lt;-+" href="#def:val Hopac.Infixes.&lt;&lt;-+">&lt;&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Stream" href="#def:module Hopac.Stream">Stream</a> <b>=</b>
  <b>type</b> <a id="dec:type Hopac.Stream.Cons" href="#def:type Hopac.Stream.Cons">Cons</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b>
    <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> of Value<b>:</b> <i>'x</i> <b>*</b> Next<b>:</b> Alt<b>&lt;</b><a href="#def:type Hopac.Stream.Cons">Cons</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
    <b>|</b> Nil
  <b>type</b> <a id="dec:type Hopac.Stream.Stream" href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><a href="#def:type Hopac.Stream.Cons">Cons</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>type</b> <a id="dec:type Hopac.Stream.Src" href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Stream.Src" href="#def:module Hopac.Stream.Src">Src</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Src.create" href="#def:val Hopac.Stream.Src.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Src.value" href="#def:val Hopac.Stream.Src.value">value</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Src.error" href="#def:val Hopac.Stream.Src.error">error</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Src.close" href="#def:val Hopac.Stream.Src.close">close</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Src.tap" href="#def:val Hopac.Stream.Src.tap">tap</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>type</b> <a id="dec:type Hopac.Stream.Var" href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Stream.Var" href="#def:module Hopac.Stream.Var">Var</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Var.create" href="#def:val Hopac.Stream.Var.create">create</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Var.get" href="#def:val Hopac.Stream.Var.get">get</a><b>:</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
    <b>val</b> <a id="dec:val Hopac.Stream.Var.set" href="#def:val Hopac.Stream.Var.set">set</a><b>:</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Stream.Var.tap" href="#def:val Hopac.Stream.Var.tap">tap</a><b>:</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.nil" href="#def:val Hopac.Stream.nil">nil</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.cons" href="#def:val Hopac.Stream.cons">cons</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.delay" href="#def:val Hopac.Stream.delay">delay</a><b>:</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.never" href="#def:val Hopac.Stream.never">never</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.error" href="#def:val Hopac.Stream.error">error</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.one" href="#def:val Hopac.Stream.one">one</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.ofSeq" href="#def:val Hopac.Stream.ofSeq">ofSeq</a><b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.indefinitely" href="#def:val Hopac.Stream.indefinitely">indefinitely</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.once" href="#def:val Hopac.Stream.once">once</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.unfoldJob" href="#def:val Hopac.Stream.unfoldJob">unfoldJob</a><b>:</b> (<i>'s</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>option<b>&lt;</b><i>'x</i> <b>*</b> <i>'s</i><b>&gt;&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.unfoldFun" href="#def:val Hopac.Stream.unfoldFun">unfoldFun</a><b>:</b> (<i>'s</i> <b>-&gt;</b> option<b>&lt;</b><i>'x</i> <b>*</b> <i>'s</i><b>&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.iterateJob" href="#def:val Hopac.Stream.iterateJob">iterateJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.iterateFun" href="#def:val Hopac.Stream.iterateFun">iterateFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.repeat" href="#def:val Hopac.Stream.repeat">repeat</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.cycle" href="#def:val Hopac.Stream.cycle">cycle</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.subscribeOnFirst" href="#def:val Hopac.Stream.subscribeOnFirst">subscribeOnFirst</a><b>:</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.subscribeDuring" href="#def:val Hopac.Stream.subscribeDuring">subscribeDuring</a><b>:</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.subscribingTo" href="#def:val Hopac.Stream.subscribingTo">subscribingTo</a><b>:</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.toObservable" href="#def:val Hopac.Stream.toObservable">toObservable</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.chooseJob" href="#def:val Hopac.Stream.chooseJob">chooseJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>option<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.chooseFun" href="#def:val Hopac.Stream.chooseFun">chooseFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> option<b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.choose" href="#def:val Hopac.Stream.choose">choose</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>option<b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.filterJob" href="#def:val Hopac.Stream.filterJob">filterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>bool<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.filterFun" href="#def:val Hopac.Stream.filterFun">filterFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.mapJob" href="#def:val Hopac.Stream.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.mapFun" href="#def:val Hopac.Stream.mapFun">mapFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.groupByJob" href="#def:val Hopac.Stream.groupByJob">groupByJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'k</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'k</i> <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
  <b>val</b> <a id="dec:val Hopac.Stream.groupByFun" href="#def:val Hopac.Stream.groupByFun">groupByFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'k</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'k</i> <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
  <b>val</b> <a id="dec:val Hopac.Stream.zip" href="#def:val Hopac.Stream.zip">zip</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.scanJob" href="#def:val Hopac.Stream.scanJob">scanJob</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.scanFun" href="#def:val Hopac.Stream.scanFun">scanFun</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.scanFromJob" href="#def:val Hopac.Stream.scanFromJob">scanFromJob</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.scanFromFun" href="#def:val Hopac.Stream.scanFromFun">scanFromFun</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.distinctByJob" href="#def:val Hopac.Stream.distinctByJob">distinctByJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'k</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
  <b>val</b> <a id="dec:val Hopac.Stream.distinctByFun" href="#def:val Hopac.Stream.distinctByFun">distinctByFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'k</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
  <b>val</b> <a id="dec:val Hopac.Stream.distinctUntilChangedWithJob" href="#def:val Hopac.Stream.distinctUntilChangedWithJob">distinctUntilChangedWithJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>bool<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.distinctUntilChangedWithFun" href="#def:val Hopac.Stream.distinctUntilChangedWithFun">distinctUntilChangedWithFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.distinctUntilChangedByJob" href="#def:val Hopac.Stream.distinctUntilChangedByJob">distinctUntilChangedByJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'k</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
  <b>val</b> <a id="dec:val Hopac.Stream.distinctUntilChangedByFun" href="#def:val Hopac.Stream.distinctUntilChangedByFun">distinctUntilChangedByFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'k</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
  <b>val</b> <a id="dec:val Hopac.Stream.amb" href="#def:val Hopac.Stream.amb">amb</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.merge" href="#def:val Hopac.Stream.merge">merge</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.append" href="#def:val Hopac.Stream.append">append</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.switch" href="#def:val Hopac.Stream.switch">switch</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.joinWith" href="#def:val Hopac.Stream.joinWith">joinWith</a><b>:</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>#<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.mapJoin" href="#def:val Hopac.Stream.mapJoin">mapJoin</a><b>:</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'z</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'z</i><b>&gt;</b>) <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'z</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.ambMap" href="#def:val Hopac.Stream.ambMap">ambMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.mergeMap" href="#def:val Hopac.Stream.mergeMap">mergeMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.appendMap" href="#def:val Hopac.Stream.appendMap">appendMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.switchMap" href="#def:val Hopac.Stream.switchMap">switchMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.skip" href="#def:val Hopac.Stream.skip">skip</a><b>:</b> int64 <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.take" href="#def:val Hopac.Stream.take">take</a><b>:</b> int64 <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.skipUntil" href="#def:val Hopac.Stream.skipUntil">skipUntil</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.takeUntil" href="#def:val Hopac.Stream.takeUntil">takeUntil</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.switchOn" href="#def:val Hopac.Stream.switchOn">switchOn</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.catch" href="#def:val Hopac.Stream.catch">catch</a><b>:</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.onCloseJob" href="#def:val Hopac.Stream.onCloseJob">onCloseJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.onCloseFun" href="#def:val Hopac.Stream.onCloseFun">onCloseFun</a><b>:</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.sample" href="#def:val Hopac.Stream.sample">sample</a><b>:</b> ticks<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> elems<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.debounce" href="#def:val Hopac.Stream.debounce">debounce</a><b>:</b> timeout<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.throttle" href="#def:val Hopac.Stream.throttle">throttle</a><b>:</b> timeout<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.combineLatest" href="#def:val Hopac.Stream.combineLatest">combineLatest</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.shift" href="#def:val Hopac.Stream.shift">shift</a><b>:</b> timeout<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.delayEach" href="#def:val Hopac.Stream.delayEach">delayEach</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.afterEach" href="#def:val Hopac.Stream.afterEach">afterEach</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.beforeEach" href="#def:val Hopac.Stream.beforeEach">beforeEach</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.atDateTimeOffsets" href="#def:val Hopac.Stream.atDateTimeOffsets">atDateTimeOffsets</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>DateTimeOffset<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>DateTimeOffset<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.atDateTimeOffset" href="#def:val Hopac.Stream.atDateTimeOffset">atDateTimeOffset</a><b>:</b> DateTimeOffset <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>DateTimeOffset<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.afterTimeSpan" href="#def:val Hopac.Stream.afterTimeSpan">afterTimeSpan</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.toSeq" href="#def:val Hopac.Stream.toSeq">toSeq</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.values" href="#def:val Hopac.Stream.values">values</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.foldJob" href="#def:val Hopac.Stream.foldJob">foldJob</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.foldFun" href="#def:val Hopac.Stream.foldFun">foldFun</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.foldFromJob" href="#def:val Hopac.Stream.foldFromJob">foldFromJob</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.foldFromFun" href="#def:val Hopac.Stream.foldFromFun">foldFromFun</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.iterJob" href="#def:val Hopac.Stream.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.iterFun" href="#def:val Hopac.Stream.iterFun">iterFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.count" href="#def:val Hopac.Stream.count">count</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>int64<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.head" href="#def:val Hopac.Stream.head">head</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.tail" href="#def:val Hopac.Stream.tail">tail</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.tails" href="#def:val Hopac.Stream.tails">tails</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.last" href="#def:val Hopac.Stream.last">last</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.init" href="#def:val Hopac.Stream.init">init</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.inits" href="#def:val Hopac.Stream.inits">inits</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>[&lt;</b>AbstractClass<b>&gt;]</b> 
  <b>type</b> <a id="dec:type Hopac.Stream.Builder" href="#def:type Hopac.Stream.Builder">Builder</a> <b>=</b>
    <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
    <b>member</b> Bind<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>member</b> Combine<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>member</b> For<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>member</b> TryWith<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>member</b> While<b>:</b> (unit <b>-&gt;</b> bool) <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>member</b> Yield<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>member</b> YieldFrom<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>abstract</b> Join<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Stream.ambed" href="#def:val Hopac.Stream.ambed">ambed</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
  <b>val</b> <a id="dec:val Hopac.Stream.appended" href="#def:val Hopac.Stream.appended">appended</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
  <b>val</b> <a id="dec:val Hopac.Stream.merged" href="#def:val Hopac.Stream.merged">merged</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
  <b>val</b> <a id="dec:val Hopac.Stream.switched" href="#def:val Hopac.Stream.switched">switched</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
</pre>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="dec:module Hopac.TopLevel" href="#def:module Hopac.TopLevel">TopLevel</a> <b>=</b>
  <b>type</b> <a id="dec:type Hopac.TopLevel.Stream" href="#def:type Hopac.TopLevel.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <a href="#def:module Hopac.Stream">Stream</a><b>.</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.job" href="#def:val Hopac.TopLevel.job">job</a><b>:</b> <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
  <b>val</b> <a id="dec:val Hopac.TopLevel.run" href="#def:val Hopac.TopLevel.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
  <b>val</b> <a id="dec:val Hopac.TopLevel.start" href="#def:val Hopac.TopLevel.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.TopLevel.startIgnore" href="#def:val Hopac.TopLevel.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.TopLevel.queue" href="#def:val Hopac.TopLevel.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.TopLevel.queueIgnore" href="#def:val Hopac.TopLevel.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.TopLevel.server" href="#def:val Hopac.TopLevel.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.TopLevel.asAlt" href="#def:val Hopac.TopLevel.asAlt">asAlt</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.asJob" href="#def:val Hopac.TopLevel.asJob">asJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.ch" href="#def:val Hopac.TopLevel.ch">ch</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.mb" href="#def:val Hopac.TopLevel.mb">mb</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.ivar" href="#def:val Hopac.TopLevel.ivar">ivar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.ivarFull" href="#def:val Hopac.TopLevel.ivarFull">ivarFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.mvar" href="#def:val Hopac.TopLevel.mvar">mvar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.mvarFull" href="#def:val Hopac.TopLevel.mvarFull">mvarFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.timeOut" href="#def:val Hopac.TopLevel.timeOut">timeOut</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.timeOutMillis" href="#def:val Hopac.TopLevel.timeOutMillis">timeOutMillis</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<h2>Description</h2>
<pre><b>namespace</b> <a id="def:namespace Hopac" href="#dec:namespace Hopac">Hopac</a>
</pre>
<div class="nested"><p> Hopac is a library for F# with the aim of making it easier to write correct, modular and efficient parallel, asynchronous, concurrent and reactive programs.  The design of Hopac draws inspiration from languages such as Concurrent ML and Cilk.  Similar to Concurrent ML, Hopac provides message passing primitives and supports the construction of first-class synchronous abstractions, see <code><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b></code>.  Parallel jobs (lightweight threads) in Hopac are created using techniques similar to the F# Async framework, see <code><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b></code>.  Hopac runs parallel jobs using a work distributing scheduler in a non-preemptive fashion.  Hopac also includes an implementation of choice streams, see <code><a href="#def:module Hopac.Stream">Stream</a><b>.</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>_<b>&gt;</b></code>, that offers a simple approach to reactive programming.</p><p> Before you begin using Hopac, make sure that you have configured your F# interactive and your application to use server garbage collection.  By default, .Net uses single-threaded workstation garbage collection, which makes it impossible for parallel programs to scale.</p><p> The documentation of many of the primitives contains a reference implementation.  In most cases, actual implementations are optimized by taking advantage of internal implementation details and may be significantly faster than the reference implementation.  The reference implementations are given for a number of reasons.  First of all, they hopefully help to better understand the semantics of the primitives.  In some cases, the reference implementations also demonstrate how you can interface Hopac with other systems without the need to extend the primitives of Hopac.  The reference implementations can also be seen as examples of how various primitives can be used to implement more complex operations.</p><p> As can quickly be observed, the various primitives and modules of Hopac are named and structured using a number of patterns.</p><p> Many modules contain a module named <code>Global</code>, which contains operations bound to the global scheduler that is implicitly managed by the Hopac library.  The global scheduler is created when an operation, such as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.run">run</a></code>, requires it.  If a program never uses an operation that requires the global scheduler, then no global scheduler will be created. This allows programs to be written that explicitly manage their own local schedulers.</p><p> Modules for various communication primitives contain a module named <code>Now</code>, which contains operations that can be efficiently performed as non-concurrent operations.  For example, there is a concurrent <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.create">create</a></code> operation, which needs to be run to create a new channel and also a <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Now">Now</a><b>.</b><a href="#def:val Hopac.Ch.Now.create">create</a></code> function that directly creates a new channel.  In cases where such efficient non-concurrent functions are provided, you should prefer to use them, because they avoid the overhead of running concurrent operations.  However, in cases where operations really need to perform concurrent operations, such as starting a concurrent server, you should prefer not to encapsulate those operations as ordinary functions, because running individual concurrent operations via some scheduler incurs overheads and it is preferable to construct longer sequences of concurrent operations to run.</p><p> For some infix operators there are both <code><a href="#def:type Hopac.Job">Job</a></code> and <code><a href="#def:type Hopac.Alt">Alt</a></code> level versions.  The <code><a href="#def:type Hopac.Alt">Alt</a></code> level versions end with a question mark <code><b>?</b></code> that indicates the selective nature of the operation.</p><p> Some higher-order operations make sense to use with both non-concurrent user defined functions and with user defined concurrent jobs and in such cases there are often two versions of the higher-order functions, with one having the suffix <code>Fun</code> and the other having the suffix <code><a href="#def:type Hopac.Job">Job</a></code>.  You should prefer the <code><a href="#def:type Hopac.Job">Job</a></code> version when you need to perform concurrent operations and otherwise the <code>Fun</code> version.<pre><b>type</b> <a id="def:type Hopac.BoundedMb" href="#dec:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a bounded synchronous mailbox for many to many communication.</p><p> Bounded synchronous mailboxes are a useful tool for coordinating work among co-operating processes.  They provide slack in the form of buffering between producers and consumers allowing them to proceed in parallel.  They also provide back-pressure in the form of blocking producers when consumers cannot keep up.</p><p> In cases where buffering is not necessary, the basic channel primitive, <code><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b>_<b>&gt;</b></code>, should be preferred.  In cases where unbounded buffering is not a problem, the basic mailbox primitive, <code><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b>_<b>&gt;</b></code>, should be preferred.</p><p> At the time of writing, <code><a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b>_<b>&gt;</b></code> is not implemented as a primitive, but is implemented using other primitives of Hopac, and it is likely that performance can be improved significantly.  If you run into a case where the performance of <code><a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b>_<b>&gt;</b></code> becomes problematic, please submit an issue.</div>
<pre><b>module</b> <a id="def:module Hopac.BoundedMb" href="#dec:module Hopac.BoundedMb">BoundedMb</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on bounded synchronous mailboxes.<pre><b>val</b> <a id="def:val Hopac.BoundedMb.create" href="#dec:val Hopac.BoundedMb.create">create</a><b>:</b> capacity<b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Returns a job that creates a new bounded mailbox with a buffer of the specified maximum capacity.  Note that a bounded mailbox with a capacity of <code>0</code> behaves exactly the same as a channel, <code><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b>_<b>&gt;</b></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.BoundedMb.put" href="#dec:val Hopac.BoundedMb.put">put</a><b>:</b> <a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Selective synchronous operation to put a message to a bounded mailbox. <code><a href="#def:val Hopac.BoundedMb.put">put</a></code> operations are processed in FIFO order and become enabled as soon as there is room in the bounded buffer.  If the buffer capacity is <code>0</code>, <code><a href="#def:val Hopac.BoundedMb.put">put</a></code> behaves exactly like <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.give">give</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.BoundedMb.take" href="#dec:val Hopac.BoundedMb.take">take</a><b>:</b> <a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Selective synchronous operation to take a message from a bounded mailbox. <code><a href="#def:val Hopac.BoundedMb.take">take</a></code> operations are processed in FIFO order and become enabled as soon as there are messages in the bounded buffer.  If the buffer capacity is <code>0</code>, <code><a href="#def:val Hopac.BoundedMb.take">take</a></code> behaves exactly like <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.take">take</a></code>.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Void" href="#dec:type Hopac.Void">Void</a>
</pre>
<div class="nested"><p> A type that has no public constructors to indicate that a job or function does not return normally.</div>
<pre><b>type</b> <a id="def:type Hopac.IAsyncDisposable" href="#dec:type Hopac.IAsyncDisposable">IAsyncDisposable</a> <b>=</b>
</pre>
<div class="nested"><p> An experimental interface for asynchronously disposable resources.  See also: <code><a href="#def:val Hopac.Job.usingAsync">usingAsync</a></code>.</p><p> The point of this interface is that resources using jobs may not be easily synchronously disposable.  Expressing the dispose operation as a job allows the operation to wait for parallel, asynchronous and concurrent operations to complete.</p><p> Note that simply calling <code>run&nbsp;(x<b>.</b><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a>&nbsp;())</code> defeats the purpose of this interface, unless it is known that the call is not made from a Hopac worker thread and no communication is needed between that thread and the dispose job.<pre><b>abstract</b> <a id="def:abstract Hopac.IAsyncDisposable.DisposeAsync" href="#dec:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that needs to be executed to dispose the resource.  The returned job should wait until the resource is properly disposed.</p><p> Note that simply calling <code><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a></code> must not immediately dispose the resource.  For example, the following pattern is incorrect:</p><pre><b>override</b> this<b>.</b><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> () <b>=</b> this<b>.</b>DisposeFlag <b>&lt;-</b> <b>true</b> ; Job<b>.</b>unit ()
</pre><p> A typical correct disposal pattern could look something like this:</p><pre><b>override</b> this<b>.</b><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> () <b>=</b>
  <a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:val Hopac.IVar.tryFill">tryFill</a> requestDisposeIVar () <a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>
  completedDisposeIVar
</pre><p> The above first signals the server to dispose by filling a synchronous variable.  This is non-blocking and does not leak resources.  Then the above waits until the server has signaled that disposal is complete.  If disposal has already been requested, the first operation does nothing. Note that two separate variables are used.</p><p> The server loop corresponding to the above could look like this:</p><pre><b>let</b> <b>rec</b> serverLoop <b>...</b> <b>=</b>
  <b>...</b>
  <b>let</b> disposeAlt () <b>=</b>
    requestDisposeIVar <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <b>fun</b> () <b>-&gt;</b>
    <b>...</b>
    completedDisposeIVar <a href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a> ()
  <b>...</b>
  <b>...</b> <a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a> disposeAlt () <a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a> <b>...</b>
</pre><p> In some cases it may be preferable to have the server loop take requests mainly from a single channel (or mailbox):</p><pre><b>let</b> <b>rec</b> serverLoop <b>...</b> <b>=</b>
  requestCh <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>function</b>
    <b>...</b>
    <b>|</b> RequestDispose <b>-&gt;</b>
      <b>...</b>
      completedDisposeIVar <a href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a> ()
    <b>...</b>
</pre><p> In such a case, one can still use the above two variable disposal pattern by spawning a process that forwards the disposal request to the server request channel before the server loop is started:</p><pre>start (requestDisposeIVar <a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a> requestCh <a href="#def:val Hopac.Infixes.&lt;--">&lt;--</a> RequestDispose)
</pre><p> Alternatively, it is usually acceptable to simply send an asynchronous dispose request to the server:</p><pre><b>override</b> this<b>.</b><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> () <b>=</b>
  requestCh <a href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a> RequestDispose <a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>
  completedDisposeIVar
</pre></div>
</div>
<pre><b>type</b> <a id="def:type Hopac.JobBuilder" href="#dec:type Hopac.JobBuilder">JobBuilder</a> <b>=</b>
</pre>
<div class="nested"><p> Expression builder type for jobs.</p><p> The following expression constructs are supported:</p><pre><b>...</b> ; <b>...</b>
<b>do</b> <b>...</b>
<b>do</b><b>!</b> <b>...</b>
<b>for</b> <b>...</b> <b>=</b> <b>...</b> <b>to</b> <b>...</b> <b>do</b> <b>...</b>
<b>for</b> <b>...</b> <b>in</b> <b>...</b> <b>do</b> <b>...</b>
<b>if</b> <b>...</b> <b>then</b> <b>...</b>
<b>if</b> <b>...</b> <b>then</b> <b>...</b> <b>else</b> <b>...</b>
<b>let</b> <b>...</b> <b>=</b> <b>...</b> <b>in</b> <b>...</b>
<b>let</b><b>!</b> <b>...</b> <b>=</b> <b>...</b> <b>|</b> async <b>|</b> task <b>in</b> <b>...</b>
<b>match</b> <b>...</b> <b>with</b> <b>...</b>
<b>return</b> <b>...</b>
<b>return</b><b>!</b> <b>...</b> <b>|</b> async <b>|</b> task
<b>try</b> <b>...</b> <b>|</b> async <b>|</b> task <b>finally</b> <b>...</b>
<b>try</b> <b>...</b> <b>|</b> async <b>|</b> task <b>with</b> <b>...</b>
<b>use</b> <b>...</b> <b>=</b> <b>...</b> <b>in</b> <b>...</b>
<b>use</b><b>!</b> <b>...</b> <b>=</b> <b>...</b> <b>|</b> async <b>|</b> task <b>in</b> <b>...</b>
<b>while</b> <b>...</b> <b>do</b> <b>...</b>
</pre><p> In the above, an ellipsis denotes either a job, an ordinary expression or a pattern.  A job workflow can also directly bind async operations, which will be started on a Hopac worker thread (see <code><a href="#def:module Hopac.Extensions.Async">Async</a><b>.</b><a href="#def:val Hopac.Extensions.Async.toJob">toJob</a></code>), and tasks (see <code><a href="#def:type Hopac.Extensions.Task">Task</a><b>.</b>awaitJob</code>).</p><p> Note that the <code><a href="#def:type Hopac.Job">Job</a></code> module provides more combinators for constructing jobs. For example, the F# workflow notation does not support <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a></code> and <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> is easier to use correctly than <code><b>try</b>&nbsp;<b>...</b>&nbsp;<b>with</b>&nbsp;<b>...</b></code> expressions.  Operators such as <code><a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a></code> and <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a></code> and operations such as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.iterate">iterate</a></code> and <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.forever">forever</a></code> are frequently useful and may improve performance.</div>
<pre><b>type</b> <a id="def:type Hopac.EmbeddedJob" href="#dec:type Hopac.EmbeddedJob">EmbeddedJob</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <b>struct</b>
</pre>
<div class="nested"><p> Represents a job to be embedded within a computation built upon jobs.</p><p> Embedded jobs can be useful when defining computations built upon jobs. Having to encode lightweight threads using the job monad is somewhat unfortunate, because it is such a fundamental abstraction.  One sometimes, perhaps even often, wants to define more interesting computations upon jobs, but the traditional way of doing that requires adding yet another costly layer of abstraction on top of jobs.  Another possibility is to expose the <code><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> type constructor as shown in the following example:</p><pre><b>type</b> Monad<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre><pre><b>type</b> MonadBuilder <b>=</b>
  <b>member</b> Delay<b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Hopac.EmbeddedJob">EmbeddedJob</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre><p> The <code>Monad<b>&lt;</b><i>'x</i><b>&gt;</b></code> type constructor and the <code>MonadBuilder</code> defines the new computation mechanism on top of jobs.  The <code>Bind</code> operation taking an <code><a href="#def:type Hopac.EmbeddedJob">EmbeddedJob</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> allows one to conveniently embed arbitrary jobs within the computations without introducing nasty overload resolution problems.</p><p> Consider what would happen if one would instead define <code>MonadBuilder</code> as follows:</p><pre><b>type</b> MonadBuilder <b>=</b>
  <b>member</b> Delay<b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>      <i>'x</i> <b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Monad<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre><p> A <code>Bind</code> operation is now almost always ambiguous and one would have to annotate bind expressions to resolve the ambiguity.</p><p> The types of the operations in the <code>MonadBuilder</code> may, at first glance, seem complicated.  Essentially the covariant positions in the signature are wrapped with the <code><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b></code> type constructor to make it possible to use lightweight threads.  In a language with built-in lightweight threads this would be unnecessary.  Reading the signature by mentally replacing every <code><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> with just <code><i>'x</i></code>, the signature should become clear.</div>
<pre><b>type</b> <a id="def:type Hopac.EmbeddedJobBuilder" href="#dec:type Hopac.EmbeddedJobBuilder">EmbeddedJobBuilder</a> <b>=</b>
</pre>
<div class="nested"><p> A builder for embedded jobs.</div>
<pre><b>type</b> <a id="def:type Hopac.Proc" href="#dec:type Hopac.Proc">Proc</a> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Represents a joinable lightweight thread of execution.</p><p> A process object makes it possible to determine when a process is known to have been terminated.  An example use for process objects would be a system where critical resources are managed by a server process and those critical resources need to be released even in case a client process suffers from a fault and is terminated before properly releasing resources.</p><p> For performance reasons, Hopac creates process objects lazily for simple jobs, because for many uses of lightweight threads such a capability is simply not necessary.  However, when process objects are known to be needed, it is better to allocate them eagerly by directly starting processes using <code><a href="#def:module Hopac.Proc">Proc</a><b>.</b><a href="#def:val Hopac.Proc.start">start</a></code> or <code><a href="#def:module Hopac.Proc">Proc</a><b>.</b><a href="#def:val Hopac.Proc.queue">queue</a></code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Proc" href="#dec:module Hopac.Proc">Proc</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on processes.<pre><b>val</b> <a id="def:val Hopac.Proc.start" href="#dec:val Hopac.Proc.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts a new process.  See also: <code><a href="#def:val Hopac.Proc.queue">queue</a></code>, <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Proc.startIgnore" href="#dec:val Hopac.Proc.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Proc.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Proc.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Proc.queue" href="#dec:val Hopac.Proc.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that queues a new process.  See also: <code><a href="#def:val Hopac.Proc.start">start</a></code>, <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Proc.queueIgnore" href="#dec:val Hopac.Proc.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Proc.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Proc.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Proc.self" href="#dec:val Hopac.Proc.self">self</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Proc">Proc</a><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that returns the current process.</p><p> Note that this is an <code>O(n)</code> operation where <code>n</code> is the number of continuation or stack frames of the current job.  In most cases this should not be an issue, but if you need to repeatedly access the process object of the current job it may be advantageous to cache it in a local variable.</div>
<pre><b>val</b> <a id="def:val Hopac.Proc.join" href="#dec:val Hopac.Proc.join">join</a><b>:</b> <a href="#def:type Hopac.Proc">Proc</a> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns an alternative that becomes available once the process is known to have been terminated for any reason.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Job" href="#dec:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a lightweight thread of execution.</p><p> Jobs are defined using expression builders like the <code><a href="#def:type Hopac.JobBuilder">JobBuilder</a></code>, accessible via the <code><a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.job">job</a></code> binding, or using monadic combinators and can then be executed on some <code><a href="#def:type Hopac.Scheduler">Scheduler</a></code> such as the global scheduler accessible via the <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a></code> module.</p><p> For example, here is a function that creates a job that computes Fibonacci numbers:</p><pre><b>let</b> <b>rec</b> fib n <b>=</b> <a href="#def:val Hopac.TopLevel.job">job</a> {
  <b>if</b> n <b>&lt;</b> 2L <b>then</b>
    <b>return</b> n
  <b>else</b>
    <b>let</b><b>!</b> (x, y) <b>=</b> fib (n<b>-</b>2L) <a href="#def:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a> fib (n<b>-</b>1L)
    <b>return</b> x<b>+</b>y
}
</pre><p> It can be run, for example, by using the global scheduler:</p><pre><b>&gt;</b> run (fib 30L) ;;
<b>val</b> it <b>:</b> int <b>=</b> 832040L
</pre><p> If you ran the above above examples, you just did the equivalent of running roughly your first million parallel jobs using Hopac.</div>
<pre><b>module</b> <a id="def:module Hopac.Job" href="#dec:module Hopac.Job">Job</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on jobs.<pre><b>module</b> <a id="def:module Hopac.Job.Global" href="#dec:module Hopac.Job.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global scheduler.</p><p> Note that in a typical program there should only be a few points (maybe just one) where jobs are started or run outside of job workflows.<pre><b>val</b> <a id="def:val Hopac.Job.Global.startWithActions" href="#dec:val Hopac.Job.Global.startWithActions">startWithActions</a><b>:</b> (exn <b>-&gt;</b> unit) <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler, but does not wait for the job to finish.  Upon the failure or success of the job, one of the given actions is called once.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</p><p> Note that using this function in a job workflow is not optimal and you should instead use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> with the desired exception handling construct (e.g. <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> or <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.catch">catch</a></code>).</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.start" href="#dec:val Hopac.Job.Global.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler, but does not wait for the job to finish.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.startIgnore" href="#dec:val Hopac.Job.Global.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> <code>startIgnore&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;start</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.queue" href="#dec:val Hopac.Job.Global.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Queues the job for execution on the global scheduler.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.queueIgnore" href="#dec:val Hopac.Job.Global.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> <code>queueIgnore&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;queue</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.server" href="#dec:val Hopac.Job.Global.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Like <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.server">server</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.run" href="#dec:val Hopac.Job.Global.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler and then blocks the current thread waiting for the job to either return successfully or fail.</p><p> WARNING: Use of <code><a href="#def:val Hopac.Job.Global.run">run</a></code> should be considered carefully, because calling <code><a href="#def:val Hopac.Job.Global.run">run</a></code> from an arbitrary thread can cause deadlock.</p><p> A call of <code><a href="#def:val Hopac.Job.Global.run">run</a>&nbsp;xJ</code> is safe when the call is not made from within a Hopac worker thread and the job <code>xJ</code> does not perform operations that might block or that might directly, or indirectly, need to communicate with the thread from which <code><a href="#def:val Hopac.Job.Global.run">run</a></code> is being called.</p><p> Note that using this function from within a job workflow should never be needed, because within a workflow the result of a job can be obtained by binding.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Job.start" href="#dec:val Hopac.Job.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that immediately starts running the given job as a separate concurrent job.  Use <code><a href="#def:module Hopac.Promise">Promise</a><b>.</b><a href="#def:val Hopac.Promise.start">start</a></code> if you need to be able to get the result.  Use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.server">server</a></code> if the job never returns normally.  See also: <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code>, <code><a href="#def:module Hopac.Proc">Proc</a><b>.</b><a href="#def:val Hopac.Proc.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.startIgnore" href="#dec:val Hopac.Job.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.queue" href="#dec:val Hopac.Job.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that schedules the given job to be run as a separate concurrent job.  Use <code><a href="#def:module Hopac.Promise">Promise</a><b>.</b><a href="#def:val Hopac.Promise.queue">queue</a></code> if you need to be able to get the result.  See also: <code><a href="#def:module Hopac.Proc">Proc</a><b>.</b><a href="#def:val Hopac.Proc.queue">queue</a></code>.</p><p> The difference between <code><a href="#def:val Hopac.Job.start">start</a></code> and <code><a href="#def:val Hopac.Job.queue">queue</a></code> is which job, the current job, or the new job, is immediately given control.  <code><a href="#def:val Hopac.Job.start">start</a></code> queues the current job, while <code><a href="#def:val Hopac.Job.queue">queue</a></code> queues the new job.  <code><a href="#def:val Hopac.Job.start">start</a></code> has slightly lower overhead than <code><a href="#def:val Hopac.Job.queue">queue</a></code> and is likely to be faster in cases where the new job blocks immediately.</p><p> For best performance the choice of which operation to use, <code><a href="#def:val Hopac.Job.start">start</a></code> or <code><a href="#def:val Hopac.Job.queue">queue</a></code>, depends on the critical path of your system.  It is generally preferable to keep control in the job that is on the critical path.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.queueIgnore" href="#dec:val Hopac.Job.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.server" href="#dec:val Hopac.Job.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Like <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.startWithFinalizer" href="#dec:val Hopac.Job.startWithFinalizer">startWithFinalizer</a><b>:</b> finalizer<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a>&nbsp;finalizerJ&nbsp;uJ</code> is like <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a>&nbsp;uJ</code>, but attaches a finalizer to the started job.  The finalizer job is started as a separate job in case the started job does not return succesfully or raise an exception and is garbage collected.  If the job either returns normally or raises an exception, the finalizer job is not started.  See also: <code><a href="#def:type Hopac.Proc">Proc</a></code>.</p><p> When a job in Hopac is aborted (see <code><a href="#def:val Hopac.Job.abort">abort</a></code>) or is, for example, blocked waiting for communication on a channel that is no longer reachable, the job can be garbage collected.  Most concurrent jobs should not need a finalizer and can be garbage collected safely in case they are blocked indefinitely or aborted.  However, in some cases it may be useful to be able to detect, for debugging reasons, or handle, for fault tolerance, a case where a job is garbage collected.  For fault tolerance the <code><a href="#def:type Hopac.Proc">Proc</a></code> abstraction may be preferable.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.startWithFinalizerIgnore" href="#dec:val Hopac.Job.startWithFinalizerIgnore">startWithFinalizerIgnore</a><b>:</b> finalizer<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.startWithFinalizerIgnore">startWithFinalizerIgnore</a>&nbsp;finalizerJ&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a>&nbsp;finalizerJ</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.delay" href="#dec:val Hopac.Job.delay">delay</a><b>:</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function to build a job that will then be run.  <code><a href="#def:val Hopac.Job.delay">delay</a>&nbsp;u2xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;()&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;u2xJ</code>.</p><p> Use of <code><a href="#def:val Hopac.Job.delay">delay</a></code> is often essential for making sure that a job constructed with user-defined code properly captures side-effects performed in the user-defined code or that a job is not constructed too eagerly (e.g. traversing an entire data structure to build a very large job object).  However, it is also the case that there is no need to wrap every constructed job with <code><a href="#def:val Hopac.Job.delay">delay</a></code> and avoiding unnecessary <code><a href="#def:val Hopac.Job.delay">delay</a></code> operations can improve performance.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.delayWith" href="#dec:val Hopac.Job.delayWith">delayWith</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function with the given value to build a job that will then be run.  <code><a href="#def:val Hopac.Job.delayWith">delayWith</a>&nbsp;x2yJ&nbsp;x</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;x&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;x2yJ</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.lift" href="#dec:val Hopac.Job.lift">lift</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function with the given value to compute the result of the job.  <code><a href="#def:val Hopac.Job.lift">lift</a>&nbsp;x2y&nbsp;x</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;x&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>&nbsp;x2y</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.thunk" href="#dec:val Hopac.Job.thunk">thunk</a><b>:</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that invokes the given thunk to compute the result of the job.  <code><a href="#def:val Hopac.Job.thunk">thunk</a>&nbsp;u2x</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;()&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>&nbsp;u2x</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Ignore" href="#dec:val Hopac.Job.Ignore">Ignore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.unit" href="#dec:val Hopac.Job.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that does nothing and returns <code>()</code>.  <code>unit&nbsp;()</code> is an optimized version of <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.result" href="#dec:val Hopac.Job.result">result</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job with the given result.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.bind" href="#dec:val Hopac.Job.bind">bind</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that first runs the given job and then passes the result of that job to the given function to build another job which will then be run.  This is the same as <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a></code> with the arguments flipped.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.join" href="#dec:val Hopac.Job.join">join</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.join">join</a>&nbsp;xJJ</code> is equivalent to <code><a href="#def:val Hopac.Job.bind">bind</a>&nbsp;id&nbsp;xJJ</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.map" href="#dec:val Hopac.Job.map">map</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and maps the result of the job with the given function.  This is the same as <code><a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a></code> with the arguments flipped.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.abort" href="#dec:val Hopac.Job.abort">abort</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that immediately terminates the current job.  See also: <code><a href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a></code>.</p><p> Note that when a job aborts, it is considered to be equivalent to having the job block indefinitely.  This means that the job neither returns succesfully nor fails with an exception.  While this may sound like something that you should worry about, it is, in fact, frequently just what you want.  That is, rather than worry about carefully terminating each and every concurrent job, it is preferable to just let them be garbage collected.  Only jobs that explicitly hold onto some important resource need to be carefully managed.</p><p> Note that in order to execute clean-up operations implemented with <code><a href="#def:val Hopac.Job.using">using</a></code> or <code><a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a></code> or <code><a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a></code> the job must either return normally or raise an exception.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.raises" href="#dec:val Hopac.Job.raises">raises</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that has the effect of raising the specified exception. <code><a href="#def:val Hopac.Job.raises">raises</a>&nbsp;e</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delayWith">delayWith</a>&nbsp;raise&nbsp;e</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Job.Infixes" href="#dec:module Hopac.Job.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Infix operators on jobs.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;=" href="#dec:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that first runs the given job and then passes the result of that job to the given function to build another job which will then be run.  This is the same as <code><a href="#def:val Hopac.Job.bind">bind</a></code> with the arguments flipped.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;." href="#dec:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given two jobs and returns the result of the second job.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>&nbsp;yJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;yJ</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes..&gt;&gt;" href="#dec:val Hopac.Job.Infixes..&gt;&gt;">.&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given two jobs and returns the result of the first job.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes..&gt;&gt;">.&gt;&gt;</a>&nbsp;yJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;yJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.|&gt;&gt;" href="#dec:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and maps the result of the job with the given function.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>&nbsp;x2y</code> is an optimized version of <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;(x2y&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>)</code>.  This is the same as <code><a href="#def:val Hopac.Job.map">map</a></code> with the arguments flipped.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;%" href="#dec:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and then returns the given value. <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>&nbsp;y</code> is an optimized version of <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>&nbsp;y</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;!" href="#dec:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and then raises the given exception.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a>&nbsp;e</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;raise&nbsp;e</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&lt;&amp;&gt;" href="#dec:val Hopac.Job.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given two jobs and then returns a pair of their results.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a>&nbsp;yJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;yJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>fun</b>&nbsp;y&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>&nbsp;(x,&nbsp;y)</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&lt;*&gt;" href="#dec:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that either runs the given jobs sequentially, like <code><a href="#def:val Hopac.Job.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a></code>, or as two separate parallel jobs and returns a pair of their results.</p><p> Note that when the jobs are run in parallel and both of them raise an exception then the created job raises an <code>AggregateException</code>.</p><p> Note that, because it is not guaranteed that the jobs would always be run as separate parallel jobs, a job such as</p><pre><b>let</b> mayDeadlock <b>=</b> <a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> c <b>=</b> <a href="#def:val Hopac.TopLevel.ch">ch</a> ()
  <a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.give">give</a> c () <a href="#def:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a> <a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.take">take</a> c
</pre><p> may deadlock.  If two jobs need to communicate with each other they need to be started as two separate jobs.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryIn" href="#dec:val Hopac.Job.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements the <code><b>try</b><b>-</b><b>in</b><b>-</b>unless</code> exception handling construct for jobs. Both of the continuation jobs <code><i>'x</i>&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for success, and <code>exn&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for failure, are invoked from a tail position.</p><p> Note that the workflow notation of F# does not support this operation.  It only supports the <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryWith">tryWith</a></code> operation.  <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> makes it easier to write exception handling code that has the desired tail-call properties.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryWith" href="#dec:val Hopac.Job.tryWith">tryWith</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements the try-with exception handling construct for jobs.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.tryWith">tryWith</a> xJ e2xJ <b>=</b> <a href="#def:val Hopac.Job.tryIn">tryIn</a> xJ <a href="#def:val Hopac.Job.result">result</a> e2xJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryFinallyFun" href="#dec:val Hopac.Job.tryFinallyFun">tryFinallyFun</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements a variation of the <code><b>try</b><b>-</b><b>finally</b></code> exception handling construct for jobs.  The given action, specified as a function, is executed after the job has been run, whether it fails or completes successfully.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a> xJ u2u <b>=</b> <a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a> xJ (<a href="#def:val Hopac.Job.thunk">thunk</a> u2u)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryFinallyJob" href="#dec:val Hopac.Job.tryFinallyJob">tryFinallyJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements a variation of the <code><b>try</b><b>-</b><b>finally</b></code> exception handling construct for jobs.  The given action, specified as a job, is executed after the job has been run, whether it fails or completes successfully.</p><p> Note that the workflow notation of F# does not support this operation.  It only supports the weaker <code><a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a></code> operation.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a> xJ uJ <b>=</b>
  <a href="#def:val Hopac.Job.tryIn">tryIn</a> xJ
   <b>&lt;|</b> <b>fun</b> x <b>-&gt;</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a> x
   <b>&lt;|</b> <b>fun</b> e <b>-&gt;</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a> e
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.using" href="#dec:val Hopac.Job.using">using</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
</pre>
<div class="nested"><p> Implements the <code><b>use</b></code> construct for jobs.  The <code>Dispose</code> method of the given disposable object is called after running the job constructed with the disposable object.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>, <code><a href="#def:val Hopac.Job.usingAsync">usingAsync</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.using">using</a> (x<b>:</b> <i>'x</i> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable) x2yJ <b>=</b>
  <a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a> (<a href="#def:val Hopac.Job.delayWith">delayWith</a> x2yJ x) (x <b>:&gt;</b> IDisposable)<b>.</b>Dispose
</pre><p> Note that the <code>Dispose</code> method is not called if the job aborts before returning from the scope of the <code><a href="#def:val Hopac.Job.using">using</a></code> job.  This is not a serious problem, because scoped disposal of managed resources is usually an optimization and unmanaged resources should already be cleaned up by finalizers.  In cases where you need to ensure scoped disposal, make sure that the job does not abort before returning.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.usingAsync" href="#dec:val Hopac.Job.usingAsync">usingAsync</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> <a href="#def:type Hopac.IAsyncDisposable">IAsyncDisposable</a>
</pre>
<div class="nested"><p> Implements an experimental <code><b>use</b></code> like construct for asynchronously disposable resources.  The <code><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a></code> method of the asynchronously disposable resource is called to construct a job that is later used to dispose the resource after the constructed job returns.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>, <code><a href="#def:val Hopac.Job.using">using</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.usingAsync">usingAsync</a> (x<b>:</b> <i>'x</i> <b>when</b> <i>'x</i> <b>:&gt;</b> <a href="#def:type Hopac.IAsyncDisposable">IAsyncDisposable</a>) x2yJ <b>=</b>
  <a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a> (<a href="#def:val Hopac.Job.delayWith">delayWith</a> x2yJ x) (x<b>.</b><a href="#def:abstract Hopac.IAsyncDisposable.DisposeAsync">DisposeAsync</a> ())
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.catch" href="#dec:val Hopac.Job.catch">catch</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Choice<b>&lt;</b><i>'x</i>, exn<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and results in either the ordinary result of the job or the exception raised by the job.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.catch">catch</a> xJ <b>=</b> <a href="#def:val Hopac.Job.tryIn">tryIn</a> xJ (<a href="#def:val Hopac.Job.lift">lift</a> Choice1Of2) (<a href="#def:val Hopac.Job.lift">lift</a> Choice2Of2)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.forN" href="#dec:val Hopac.Job.forN">forN</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job sequentially the given number of times.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forN">forN</a> n uJ <b>=</b>
  <b>if</b> n <b>&gt;</b> 0 <b>then</b>
    uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> () <b>-&gt;</b> <a href="#def:val Hopac.Job.forN">forN</a> (n <b>-</b> 1) uJ
  <b>else</b>
    Job<b>.</b>unit ()
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.forNIgnore" href="#dec:val Hopac.Job.forNIgnore">forNIgnore</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forNIgnore">forNIgnore</a>&nbsp;n&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.forN">forN</a>&nbsp;n</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forUpTo" href="#dec:val Hopac.Job.forUpTo">forUpTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forUpTo">forUpTo</a>&nbsp;lo&nbsp;hi&nbsp;i2uJ</code> creates a job that sequentially iterates from <code>lo</code> to <code>hi</code> (inclusive) and calls the given function to construct jobs that will be executed.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forUpTo">forUpTo</a> lo hi i2uJ <b>=</b>
  <b>if</b> lo <b>&lt;=</b> hi <b>then</b>
    i2uJ lo <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> () <b>-&gt;</b> <a href="#def:val Hopac.Job.forUpTo">forUpTo</a> (lo <b>+</b> 1) hi i2uJ
  <b>else</b>
    Job<b>.</b>unit ()
</pre><p> Rationale: The reason for iterating over an inclusive range is to make this construct work like a <code><b>for</b>&nbsp;<b>...</b>&nbsp;<b>to</b>&nbsp;<b>...</b>&nbsp;<b>do</b>&nbsp;<b>...</b></code> loop of the base F# language.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forUpToIgnore" href="#dec:val Hopac.Job.forUpToIgnore">forUpToIgnore</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forUpToIgnore">forUpToIgnore</a>&nbsp;lo&nbsp;hi&nbsp;i2xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.forUpTo">forUpTo</a>&nbsp;lo&nbsp;hi&nbsp;(i2xJ&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>)</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forDownTo" href="#dec:val Hopac.Job.forDownTo">forDownTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forDownTo">forDownTo</a>&nbsp;hi&nbsp;lo&nbsp;i2uJ</code> creates a job that sequentially iterates from <code>hi</code> to <code>lo</code> (inclusive) and calls the given function to construct jobs that will be executed.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forDownTo">forDownTo</a> hi lo i2uJ <b>=</b>
  <b>if</b> hi <b>&gt;=</b> lo <b>then</b>
    i2uJ hi <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> () <b>-&gt;</b> <a href="#def:val Hopac.Job.forDownTo">forDownTo</a> (hi <b>-</b> 1) lo i2uJ
  <b>else</b>
    Job<b>.</b>unit ()
</pre><p> Rationale: The reason for iterating over an inclusive range is to make this construct work like a <code><b>for</b>&nbsp;<b>...</b>&nbsp;<b>downto</b>&nbsp;<b>...</b>&nbsp;<b>do</b>&nbsp;<b>...</b></code> loop of the base F# language.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forDownToIgnore" href="#dec:val Hopac.Job.forDownToIgnore">forDownToIgnore</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forDownToIgnore">forDownToIgnore</a>&nbsp;hi&nbsp;lo&nbsp;i2xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.forDownTo">forDownTo</a>&nbsp;hi&nbsp;lo&nbsp;(i2xJ&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>)</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.whileDo" href="#dec:val Hopac.Job.whileDo">whileDo</a><b>:</b> (unit <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.whileDo">whileDo</a>&nbsp;u2b&nbsp;uJ</code> creates a job that sequentially executes the <code>uJ</code> job as long as <code>u2b&nbsp;()</code> returns <code><b>true</b></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.whileDo">whileDo</a> u2b uJ <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> <b>rec</b> loop () <b>=</b>
    <b>if</b> u2b () <b>then</b>
      uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> () <b>-&gt;</b> loop ()
    <b>else</b>
      Job<b>.</b>unit ()
  loop ()
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.whileDoIgnore" href="#dec:val Hopac.Job.whileDoIgnore">whileDoIgnore</a><b>:</b> (unit <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.whileDoIgnore">whileDoIgnore</a>&nbsp;u2b&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.whileDo">whileDo</a>&nbsp;u2b</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.whenDo" href="#dec:val Hopac.Job.whenDo">whenDo</a><b>:</b> bool <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.whenDo">whenDo</a>&nbsp;b&nbsp;uJ</code> is equivalent to <code><b>if</b>&nbsp;b&nbsp;<b>then</b>&nbsp;uJ&nbsp;<b>else</b>&nbsp;Job<b>.</b>unit&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forever" href="#dec:val Hopac.Job.forever">forever</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that repeats the given job indefinitely.  See also: <code><a href="#def:val Hopac.Job.foreverServer">foreverServer</a></code>, <code><a href="#def:val Hopac.Job.iterate">iterate</a></code>.</p><p> It is a common programming pattern to use server jobs that loop indefinitely and communicate with clients via channels.  When a job is blocked waiting for communication on one or more channels and the channels become garbage (no longer reachable by any other job) the job can be garbage collected as well.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forever">forever</a> uJ <b>=</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> () <b>-&gt;</b> <a href="#def:val Hopac.Job.forever">forever</a> uJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.foreverIgnore" href="#dec:val Hopac.Job.foreverIgnore">foreverIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.foreverIgnore">foreverIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.forever">forever</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.iterate" href="#dec:val Hopac.Job.iterate">iterate</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that indefinitely iterates the given job constructor starting with the given value.  See also: <code><a href="#def:val Hopac.Job.iterateServer">iterateServer</a></code>, <code><a href="#def:val Hopac.Job.forever">forever</a></code>.</p><p> It is a common programming pattern to use server jobs that loop indefinitely and communicate with clients via channels.  When a job is blocked waiting for communication on one or more channels and the channels become garbage (no longer reachable by any other job) the job can be garbage collected as well.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.iterate">iterate</a> x x2xJ <b>=</b>
  x2xJ x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> x <b>-&gt;</b> <a href="#def:val Hopac.Job.iterate">iterate</a> x x2xJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.foreverServer" href="#dec:val Hopac.Job.foreverServer">foreverServer</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts a separate server job that repeats the given job indefinitely.  <code><a href="#def:val Hopac.Job.foreverServer">foreverServer</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.forever">forever</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.server">server</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.iterateServer" href="#dec:val Hopac.Job.iterateServer">iterateServer</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts a separate server job that indefinitely iterates the given job constructor starting with the given value.  <code><a href="#def:val Hopac.Job.iterateServer">iterateServer</a>&nbsp;x&nbsp;x2xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.iterate">iterate</a>&nbsp;x&nbsp;x2xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.server">server</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.seqCollect" href="#dec:val Hopac.Job.seqCollect">seqCollect</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs in sequence and returns a list of the results.  See also: <code><a href="#def:val Hopac.Job.seqIgnore">seqIgnore</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.seqCollect">seqCollect</a> (xJs<b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> xs <b>=</b> ResizeArray<b>&lt;</b>_<b>&gt;</b>()
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.using">using</a> (xJs<b>.</b>GetEnumerator ()) <b>&lt;|</b> <b>fun</b> xJs <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xJs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    xJs<b>.</b>Current <a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a> xs<b>.</b>Add) <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>
  xs
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.seqIgnore" href="#dec:val Hopac.Job.seqIgnore">seqIgnore</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs in sequence.  The results of the jobs are ignored.  See also: <code><a href="#def:val Hopac.Job.seqCollect">seqCollect</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.seqIgnore">seqIgnore</a> (uJs<b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.using">using</a> (uJs<b>.</b>GetEnumerator ()) <b>&lt;|</b> <b>fun</b> uJs <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> uJs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    uJs<b>.</b>Current)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.conCollect" href="#dec:val Hopac.Job.conCollect">conCollect</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs as separate concurrent jobs and returns a list of the results.</p><p> Note that when multiple jobs raise exceptions, then the created job raises an <code>AggregateException</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.conIgnore" href="#dec:val Hopac.Job.conIgnore">conIgnore</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish.  The results of the jobs are ignored.</p><p> Note that when multiple jobs raise exceptions, then the created job raises an <code>AggregateException</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.fromBeginEnd" href="#dec:val Hopac.Job.fromBeginEnd">fromBeginEnd</a><b>:</b> (AsyncCallback <b>*</b> obj <b>-&gt;</b> IAsyncResult)
               <b>-&gt;</b> (IAsyncResult <b>-&gt;</b> <i>'x</i>)
               <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that performs the asynchronous operation defined by the given pair of begin and end operations.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a> doBegin doEnd <b>=</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.scheduler">scheduler</a> () <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> sr <b>-&gt;</b>
  <b>let</b> xI <b>=</b> <a href="#def:val Hopac.TopLevel.ivar">ivar</a> ()
  doBegin <b>&lt;|</b> AsyncCallback (<b>fun</b> ar <b>-&gt;</b>
    <a href="#def:module Hopac.Scheduler">Scheduler</a><b>.</b><a href="#def:val Hopac.Scheduler.start">start</a> sr (<b>try</b> xI <a href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a> doEnd ar <b>with</b> e <b>-&gt;</b> xI <a href="#def:val Hopac.Infixes.&lt;-=!">&lt;-=!</a> e))
  <b>|&gt;</b> ignore
  <b>upcast</b> xI
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.fromEndBegin" href="#dec:val Hopac.Job.fromEndBegin">fromEndBegin</a><b>:</b> (IAsyncResult <b>-&gt;</b> <i>'x</i>)
               <b>-&gt;</b> (AsyncCallback <b>*</b> obj <b>-&gt;</b> IAsyncResult)
               <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.fromEndBegin">fromEndBegin</a>&nbsp;doEnd&nbsp;doBegin</code> is equivalent to <code><a href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a>&nbsp;doBegin&nbsp;doEnd</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.scheduler" href="#dec:val Hopac.Job.scheduler">scheduler</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Scheduler">Scheduler</a><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that returns the scheduler under which the job is being run. This allows interfacing Hopac with existing asynchronous operations that do not fall into a pattern that is already supported explicitly.  See, for example, the reference implementation of <code><a href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a></code>.  The key is that the job that is suspended for the duration of the asynchronous operation can then be resumed on the same scheduler.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.switchToWorker" href="#dec:val Hopac.Job.switchToWorker">switchToWorker</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that ensures that the immediately following operation will be executed on a Hopac worker thread.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.paranoid" href="#dec:val Hopac.Job.paranoid">paranoid</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Given a job, creates a new job that behaves exactly like the given job, except that the new job obviously cannot be directly downcast to the underlying type of the given job.  This operation is provided for debugging purposes.  You can always break abstractions using reflection. See also: <code><a href="#def:module Hopac.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Alt.paranoid">paranoid</a></code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Job.Random" href="#dec:module Hopac.Job.Random">Random</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the built-in pseudo random number generator (PRNG) of Hopac.</p><p> Note that every actual Hopac worker thread has its own PRNG state and is initialized with a distinct seed.  However, when you <code><a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.start">start</a></code> or <code><a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.run">run</a></code> jobs from some non worker thread, it is possible that successive executions generate the same sequence of numbers.  In the extremely rare case that could be a problem, use <code><a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.queue">queue</a></code> or <code><a href="#def:val Hopac.Job.switchToWorker">switchToWorker</a></code>.<pre><b>val</b> <a id="def:val Hopac.Job.Random.bind" href="#dec:val Hopac.Job.Random.bind">bind</a><b>:</b> (uint64 <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>bind&nbsp;r2xJ</code> creates a job that calls the given job constructor with a pseudo random 64-bit unsigned integer.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Random.map" href="#dec:val Hopac.Job.Random.map">map</a><b>:</b> (uint64 <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>map&nbsp;r2x</code> is equivalent to <code>bind&nbsp;(r2x&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>)</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Random.get" href="#dec:val Hopac.Job.Random.get">get</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>uint64<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that generates a pseudo random 64-bit unsigned integer.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Alt" href="#dec:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a first-class selective synchronous operation.</p><p> The inspiration for alternatives comes from the events of Concurrent ML. The term ''alternative'' was chosen, because the term ''event'' is already widely used in .Net.</p><p> Simpler forms of selective synchronization exists in various languages.  For example, the occam language has an <code>alt</code> statement, the Go language has a <code>select</code> statement and Clojure's core.async has an <code>alt</code> function.  In Hopac and Concurrent ML, selective synchronous operations are not limited to primitive message passing operations (see <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.give">give</a></code> and <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.take">take</a></code>), but are instead first-class values (see <code>choose</code>) and can be extended with user-defined code (see <code><a href="#def:val Hopac.Alt.wrap">wrap</a></code> and <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>) allowing the encapsulation of concurrent protocols as selective synchronous operations.</p><p> The idea of alternatives is to allow one to introduce new selective synchronous operations to be used with non-determinic choice aka <code>choose</code>. Obviously, when you have a concurrent server that responds to some protocol, you don't have to perform the protocol as a selective synchronous operation. However, if you do encapsulate the protocol as a selective synchronous operation, you can then combine the operation with other selective synchronous operations.  That is the essence of Hopac and CML.</p><p> If a selective synchronous operation is not committed to then it should have essentially no effect.  In order to create such alternatives, one may take advantage of idempotency, rendezvous and negative acknowledgments.  Here are few rules of thumb:</p><p> - If you don't need to send arguments to the server, you can synchronize using a <code>take</code> operation on the server's reply channel.  E.g. an operation to take an element from a concurrent buffer.</p><p> - If you don't need a result from the server, aside from acknowledgment that the operation has been performed, you can synchronize using a <code>give</code> operation on the server's request channel.  E.g. an operation to remove a specified element from a concurrent bag.</p><p> - If you have an idempotent operation, you can use <code><a href="#def:val Hopac.Alt.guard">guard</a></code> to send the arguments and a write once variable to the server and then synchronize using a <code>read</code> operation on the write once variable for the reply.  E.g. request to receive a timeout event.</p><p> - If you have a non-idempotent operation, you can use <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> to send the arguments, negative acknowledgment token and a channel to the server and then synchronize using a <code>take</code> operation on the channel for the reply.  See <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> for an illustrative toy example.</p><p> Note that <code><a href="#def:type Hopac.Alt">Alt</a></code> is a subtype of <code><a href="#def:type Hopac.Job">Job</a></code>.  You can use an alternative in any context that requires a job.</div>
<pre><b>module</b> <a id="def:module Hopac.Alt" href="#dec:module Hopac.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on first-class synchronous operations or alternatives.<pre><b>val</b> <a id="def:val Hopac.Alt.always" href="#dec:val Hopac.Alt.always">always</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is always available and results in the given value.</p><p> Note that when there are alternatives immediately available in a choice, the first such alternative will be committed to.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.unit" href="#dec:val Hopac.Alt.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns an alternative that is always available and results in the unit value.  <code>unit&nbsp;()</code> is an optimized version of <code><a href="#def:val Hopac.Alt.always">always</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.never" href="#dec:val Hopac.Alt.never">never</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is never available.</p><p> Note that synchronizing on <code><a href="#def:val Hopac.Alt.never">never</a>&nbsp;()</code>, without other alternatives, is equivalent to performing <code><a href="#def:val Hopac.Job.abort">abort</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.zero" href="#dec:val Hopac.Alt.zero">zero</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns an alternative that is never available.  <code><a href="#def:val Hopac.Alt.zero">zero</a>&nbsp;()</code> is an optimized version of <code><a href="#def:val Hopac.Alt.never">never</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.once" href="#dec:val Hopac.Alt.once">once</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns an alternative that can be committed to once and that produces the given value.</p><p> <code><a href="#def:val Hopac.Alt.once">once</a></code> is basically an optimized version of</p><pre><b>let</b> <a href="#def:val Hopac.Alt.once">once</a> x <b>=</b>
  <b>let</b> xCh <b>=</b> <a href="#def:val Hopac.TopLevel.ch">ch</a> ()
  run (xCh <a href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a> x)
  <a href="#def:val Hopac.Alt.paranoid">paranoid</a> xCh
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.raises" href="#dec:val Hopac.Alt.raises">raises</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that has the effect of raising the specified exception.  <code><a href="#def:val Hopac.Alt.raises">raises</a>&nbsp;e</code> is equivalent to <code><a href="#def:val Hopac.Alt.delay">delay</a>&nbsp;<b>&lt;|</b>&nbsp;<b>fun</b>&nbsp;()&nbsp;<b>-&gt;</b>&nbsp;raise&nbsp;e</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.guard" href="#dec:val Hopac.Alt.guard">guard</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the given job.  See also: <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>.</p><p> <code><a href="#def:val Hopac.Alt.guard">guard</a></code> allows client-server protocols that do not require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.  For example, the given job may create and send a request to a server and then return an alternative that waits for the server's reply.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.guard">guard</a> xAJ <b>=</b> <a href="#def:val Hopac.Alt.withNack">withNack</a> <b>&lt;|</b> <b>fun</b> _ <b>-&gt;</b> xAJ
</pre><p> Note that, like with <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>, it is essential to avoid blocking inside <code><a href="#def:val Hopac.Alt.guard">guard</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.delay" href="#dec:val Hopac.Alt.delay">delay</a><b>:</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the given thunk.</p><p> <code><a href="#def:val Hopac.Alt.delay">delay</a></code> is an optimized weaker form of <code><a href="#def:val Hopac.Alt.guard">guard</a></code> that can be used when no concurrent operations beyond the returned alternative are required by the encapsulated request protocol.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.delay">delay</a> u2xA <b>=</b> <a href="#def:val Hopac.Alt.guard">guard</a> (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.thunk">thunk</a> u2xA)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.random" href="#dec:val Hopac.Alt.random">random</a><b>:</b> (uint64 <b>-&gt;</b> #<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the the given function, which will be called with a pseudo random 64-bit unsigned integer.  See also: <code><a href="#def:module Hopac.Job.Random">Random</a><b>.</b><a href="#def:val Hopac.Job.Random.bind">bind</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.withNack" href="#dec:val Hopac.Alt.withNack">withNack</a><b>:</b> (<a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the given job constructed with a negative acknowledgment alternative.  See also: <code><a href="#def:val Hopac.Alt.guard">guard</a></code>.</p><p> <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> allows client-server protocols that do require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.  The negative acknowledgment alternative will be available in case some other instantiated alternative involved in the choice is committed to instead.</p><p> Like <code><a href="#def:val Hopac.Alt.guard">guard</a></code>, <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> is typically used to encapsulate the client side operation of a concurrent protocol.  The client side operation typically constructs a request, containing the negative acknowledgment alternative, sends it to a server and then returns an alternative that waits for a rendezvous with the server.  In case the client later commits to some other alternative, the negative acknowledgment token becomes available and the server can also abort the operation.</p><p> Here is a simple example of an operation encapsulated using <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>. The idea is that we have a server that maintains a counter.  Clients can request the server to increment the counter by a specific amount and return the incremented counter value.  We further want to make it so that in case the client does not commit to the operation, the counter in the server is not updated.</p><p> Here is the server communication channel and the server loop:</p><pre><b>let</b> counterServer <b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b>int <b>*</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b>int<b>&gt;&gt;</b> <b>=</b>
  <b>let</b> reqCh <b>=</b> <a href="#def:val Hopac.TopLevel.ch">ch</a> ()
  server <b>&lt;&lt;</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.iterate">iterate</a> 0 <b>&lt;|</b> <b>fun</b> oldCounter <b>-&gt;</b>
    reqCh <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> (n, nack, replyCh) <b>-&gt;</b>
    <b>let</b> newCounter <b>=</b> oldCounter <b>+</b> n
    (replyCh <a href="#def:val Hopac.Infixes.&lt;--">&lt;--</a> newCounter <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a> newCounter) <a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>
    (nack                   <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a> oldCounter)
  reqCh
</pre><p> Note how the server tries to synchronize on either giving the new counter value to the client or the negative acknowledgment.</p><p> Here is the encapsulated client side operation:</p><pre><b>let</b> incrementBy n <b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>int<b>&gt;</b> <b>=</b> <a href="#def:module Hopac.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Alt.withNack">withNack</a> <b>&lt;|</b> <b>fun</b> nack <b>-&gt;</b>
  <b>let</b> replyCh <b>=</b> <a href="#def:val Hopac.TopLevel.ch">ch</a> ()
  counterServer <a href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a> (n, nack, replyCh) <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>
  <b>upcast</b> replyCh
</pre><p> The client side operation just sends the negative acknowledgment to the server as a part of the request.  It is essential that a synchronous rendezvous via a channel, rather than e.g. a write once variable, is used for the reply.  It is also essential to avoid blocking inside <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>, which is why an asynchronous send is used inside the client side operation.</p><p> Note that if an alternative created with <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> is not instantiated, then no negative acknowledgment is created.  For example, given an alternative of the form <code><a href="#def:val Hopac.Alt.always">always</a>&nbsp;()&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>&nbsp;<a href="#def:val Hopac.Alt.withNack">withNack</a>&nbsp;(<b>...</b>)</code> the <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> alternative is never instantiated.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.wrapAbort" href="#dec:val Hopac.Alt.wrapAbort">wrapAbort</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a new alternative that upon picking time makes it so that the given job will be started if the given alternative isn't the one being picked.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.wrapAbort">wrapAbort</a> (abortAct<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) (evt<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b>
  <a href="#def:module Hopac.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Alt.withNack">withNack</a> <b>&lt;|</b> <b>fun</b> abortAlt <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a> (abortAlt <a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a> abortAct) <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a> evt
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.choose" href="#dec:val Hopac.Alt.choose">choose</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is available when any one of the given alternatives is.  See also: <code><a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a></code>.</p><p> Note that <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[]</code> is equivalent to <code><a href="#def:val Hopac.Alt.never">never</a>&nbsp;()</code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.choose">choose</a> xAs <b>=</b> <a href="#def:module Hopac.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Alt.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  Seq<b>.</b>foldBack (<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>) xAs (<a href="#def:val Hopac.Alt.never">never</a> ())
</pre><p> Above, <code>Seq<b>.</b>foldBack</code> has the obvious meaning.  Alternatively we could define <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>&nbsp;xA2</code> to be equivalent to <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[xA1;&nbsp;xA2]</code> and consider <code><a href="#def:val Hopac.Alt.choose">choose</a></code> as primitive.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.chooser" href="#dec:val Hopac.Alt.chooser">chooser</a><b>:</b> seq<b>&lt;</b>#<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Alt.chooser">chooser</a>&nbsp;xAs</code> is like <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;xAs</code> except that the order in which the alternatives from the sequence are considered will be determined at random each time the alternative is used.  See also: <code><a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.wrap" href="#dec:val Hopac.Alt.wrap">wrap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative whose result is passed to the given job constructor and processed with the resulting job after the given alternative has been committed to.  This is the same as <code><a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a></code> with the arguments flipped.</p><p> Note that although this operator has a type similar to a monadic bind operation, alternatives do not form a monad (with the <code><a href="#def:val Hopac.Alt.always">always</a></code> alternative constructor).  So called Transactional Events do form a monad, but require a more complex synchronization protocol.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.map" href="#dec:val Hopac.Alt.map">map</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Alt.map">map</a>&nbsp;x2y</code> is equivalent to <code>xA&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Alt.wrap">wrap</a>&nbsp;(x2y&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>)</code>.  This is the same as <code><a href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a></code> with the arguments flipped.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.Ignore" href="#dec:val Hopac.Alt.Ignore">Ignore</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Alt.Ignore">Ignore</a>&nbsp;xA</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;()</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Alt.Infixes" href="#dec:module Hopac.Alt.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Infix operators on alternatives.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&lt;|&gt;?" href="#dec:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is available when either of the given alternatives is available.  <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>&nbsp;xA2</code> is an optimized version of <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[xA1;&nbsp;xA2]</code>.</p><p> The given alternatives are processed in a left-to-right order with short-cut evaluation.  In other words, given an alternative of the form <code>first&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>&nbsp;second</code>, the <code>first</code> alternative is first instantiated and, if it is available, is committed to and the <code>second</code> alternative will not be instantiated at all.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&lt;~&gt;?" href="#dec:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>&nbsp;xA2</code> is like <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a>&nbsp;xA2</code> except that the order in which <code>xA1</code> and <code>xA2</code> are considered is determined at random every time the alternative is used.  See also: <code><a href="#def:val Hopac.Alt.chooser">chooser</a></code>.</p><p> WARNING: Chained uses of <code><a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a></code> do not lead to uniform distributions. Consider the expression <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>&nbsp;xA2&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>&nbsp;xA3</code>.  It parenhesizes as <code>(xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>&nbsp;xA2)&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;~&gt;?">&lt;~&gt;?</a>&nbsp;xA3</code>.  This means that <code>xA3</code> has a 50% and both <code>xA1</code> and <code>xA2</code> have 25% probability of being considered first.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;=?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative whose result is passed to the given job constructor and processed with the resulting job after the given alternative has been committed to.  This is the same as <code><a href="#def:val Hopac.Alt.wrap">wrap</a></code> with the arguments flipped.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;.?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;.?">&gt;&gt;.?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;.?">&gt;&gt;.?</a>&nbsp;yJ</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;yJ</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes..&gt;&gt;?" href="#dec:val Hopac.Alt.Infixes..&gt;&gt;?">.&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes..&gt;&gt;?">.&gt;&gt;?</a>&nbsp;yJ</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;yJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.|&gt;&gt;?" href="#dec:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a>&nbsp;x2y</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>&nbsp;(x2y&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>)</code>.  This is the same as <code><a href="#def:val Hopac.Alt.map">map</a></code> with the arguments flipped.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;%?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a>&nbsp;y</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>&nbsp;y</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;!?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;!?">&gt;&gt;!?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;!?">&gt;&gt;!?</a>&nbsp;e</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;raise&nbsp;e</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&lt;+&gt;?" href="#dec:val Hopac.Alt.Infixes.&lt;+&gt;?">&lt;+&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'a</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'b</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'a</i> <b>*</b> <i>'b</i><b>&gt;</b>
</pre>
<div class="nested"><p> An alternative that is equivalent to first picking either one of the given alternatives and then picking the other alternative.  Note that this is not the same as picking the alternatives in a single transaction.  Such an operation would require a more complex synchronization protocol like with the so called Transactional Events.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.tryIn" href="#dec:val Hopac.Alt.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements the <code><b>try</b><b>-</b><b>in</b><b>-</b>unless</code> exception handling construct for alternatives.  Both of the continuation jobs <code><i>'x</i>&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for success, and <code>exn&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for failure, are invoked from a tail position.</p><p> Exceptions from both before and after the commit point can be handled.  An exception that occurs before a commit point, from the user code in a <code><a href="#def:val Hopac.Alt.guard">guard</a></code>, <code><a href="#def:val Hopac.Alt.delay">delay</a></code>, or <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>, results in treating that exception as the commit point.</p><p> Note you can also use function or job level exception handling before the commit point within the user code in a <code><a href="#def:val Hopac.Alt.guard">guard</a></code>, <code><a href="#def:val Hopac.Alt.delay">delay</a></code>, or <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.tryFinallyFun" href="#dec:val Hopac.Alt.tryFinallyFun">tryFinallyFun</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements a variation of the <code><b>try</b><b>-</b><b>finally</b></code> exception handling construct for alternatives.  The given action, specified as a function, is executed after the alternative has been committed to, whether the alternative fails or completes successfully.  Note that the action is not executed in case the alternative is not committed to.  Use <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> to attach the action to the non-committed case.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.tryFinallyFun">tryFinallyFun</a> xA u2u <b>=</b> <a href="#def:val Hopac.Alt.tryFinallyJob">tryFinallyJob</a> xA (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.thunk">thunk</a> u2u)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.tryFinallyJob" href="#dec:val Hopac.Alt.tryFinallyJob">tryFinallyJob</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements a variation of the <code><b>try</b><b>-</b><b>finally</b></code> exception handling construct for alternatives.  The given action, specified as a job, is executed after the alternative has been committed to, whether the alternative fails or completes successfully.  Note that the action is not executed in case the alternative is not committed to.  Use <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> to attach the action to the non-committed case.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.tryFinallyJob">tryFinallyJob</a> xA uJ <b>=</b>
  <a href="#def:val Hopac.Alt.tryIn">tryIn</a> xA
   <b>&lt;|</b> <b>fun</b> x <b>-&gt;</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a> x
   <b>&lt;|</b> <b>fun</b> e <b>-&gt;</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a> e
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.paranoid" href="#dec:val Hopac.Alt.paranoid">paranoid</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Given an alternative, creates a new alternative that behaves exactly like the given alternative, except that the new alternative obviously cannot be directly downcast to the underlying type of the given alternative.  This operation is provided for debugging purposes.  You can always break abstractions using reflection.  See also: <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.paranoid">paranoid</a></code>.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Timer" href="#dec:module Hopac.Timer">Timer</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on a wall-clock timer.<pre><b>module</b> <a id="def:module Hopac.Timer.Global" href="#dec:module Hopac.Timer.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global wall-clock timer.  The global timer is implicitly associated with the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Timer.Global.timeOut" href="#dec:val Hopac.Timer.Global.timeOut">timeOut</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, after instantiation, becomes available after the specified time span.</p><p> Note that this is simply not intended for high precision timing and the resolution of the underlying timing mechanism is very coarse (Windows system ticks).</p><p> Note that you do not need to create a new timeout alternative every time you need a timeout with a specific time span.</p><p> For example, you can create a timeout for one second</p><pre><b>let</b> after1s <b>=</b> <a href="#def:val Hopac.Timer.Global.timeOut">timeOut</a> (TimeSpan<b>.</b>FromSeconds 1.0)
</pre><p> and then use that timeout many times</p><pre>choose [
  makeRequest <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <b>fun</b> rp <b>-&gt;</b> <b>...</b>
  after1s     <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <b>fun</b> () <b>-&gt;</b> <b>...</b>
]
</pre><p> Timeouts, like other alternatives, can also directly be used as job level operations.  For example, using the above definition of <code>after1s</code></p><pre>after1s <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> () <b>-&gt;</b> <b>...</b>
</pre><p> has the effect of sleeping for one second.</p><p> It is an idiomatic approach with Hopac to rely on garbage collection to clean up concurrent jobs than can no longer make progress.  It is therefore important to note that a server loop</p><pre><b>let</b> <b>rec</b> serverLoop <b>...</b> <b>=</b>
  <b>...</b> <a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a> (<a href="#def:val Hopac.Timer.Global.timeOut">timeOut</a> <b>...</b> <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <b>...</b> serverLoop <b>...</b>) <a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a> <b>...</b>
</pre><p> that always waits for a timeout is held live by the timeout.  Such servers need to support an explicit kill protocol.</div>
<pre><b>val</b> <a id="def:val Hopac.Timer.Global.timeOutMillis" href="#dec:val Hopac.Timer.Global.timeOutMillis">timeOutMillis</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Timer.Global.timeOutMillis">timeOutMillis</a>&nbsp;n</code> is equivalent to <code><a href="#def:val Hopac.Timer.Global.timeOut">timeOut</a>&nbsp;(TimeSpan<b>.</b>FromMilliseconds&nbsp;(float&nbsp;n))</code>.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Ch" href="#dec:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a synchronous channel.</p><p> Channels provide a simple rendezvous mechanism for concurrent jobs and are designed to be used as the building blocks of selective synchronous abstractions.</p><p> Channels are lightweight objects and it is common to allocate fresh channels for short-term, possibly even one-shot, communications.  When simple rendezvous is not needed in a one-shot communication, a write once variable, <code><a href="#def:type Hopac.IVar">IVar</a></code>, may offer slightly better performance.</p><p> Channels are optimized for synchronous message passing, which can often be done without buffering.  Channels also provide an asynchronous <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a></code> operation, but in situations where buffering is needed, some other message passing mechanism such as a bounded mailbox, <code><a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b>_<b>&gt;</b></code>, or unbounded mailbox, <code><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b>_<b>&gt;</b></code>, may be preferable.</p><p> Note that <code><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is a subtype of <code><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> and <code>xCh&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.take">take</a>&nbsp;xCh</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Ch" href="#dec:module Hopac.Ch">Ch</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on synchronous channels.<pre><b>module</b> <a id="def:module Hopac.Ch.Now" href="#dec:module Hopac.Ch.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on synchronous channels.<pre><b>val</b> <a id="def:val Hopac.Ch.Now.create" href="#dec:val Hopac.Ch.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new channel.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Ch.Global" href="#dec:module Hopac.Ch.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations bound to the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Ch.Global.send" href="#dec:val Hopac.Ch.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sends the given value to the specified channel.  <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Global">Global</a><b>.</b><a href="#def:val Hopac.Ch.Global.send">send</a>&nbsp;xCh&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a>&nbsp;xCh&nbsp;x&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.start">start</a></code>.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a></code> instead.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.create" href="#dec:val Hopac.Ch.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new channel.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.give" href="#dec:val Hopac.Ch.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.  See also: <code><a href="#def:val Hopac.Infixes.&lt;--">&lt;--</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.take" href="#dec:val Hopac.Ch.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, at instantiation time, offers to take a value from another job on the given channel, and becomes available when another job offers to give a value.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.send" href="#dec:val Hopac.Ch.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends a value to another job on the given channel.  A send operation is asynchronous.  In other words, a send operation does not wait for another job to give the value to.</p><p> Note that channels have been optimized for synchronous operations; an occasional send can be efficient, but when sends are queued, performance maybe be significantly worse than with a <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code> optimized for buffering.  See also: <code><a href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a></code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Ch.Try" href="#dec:module Hopac.Ch.Try">Try</a> <b>=</b>
</pre>
<div class="nested"><p> Polling, or non-blocking, operations on synchronous channels.</p><p> Note that polling operations only make sense when the other side of the communication is blocked waiting on the channel.  If both a giver and a taker use polling operations on a channel, it is not guaranteed that communication will ever happen.</p><p> Also note that a job that performs arbitrarily many polling operations without blocking should not be used in a cooperative system, like Hopac, because such a job completely uses up a single core and prevents other ready jobs from being executed.  Jobs that perform polling should be designed so that after a finitely many poll operations they will block waiting for communication.<pre><b>val</b> <a id="def:val Hopac.Ch.Try.give" href="#dec:val Hopac.Ch.Try.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>bool<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that attempts to give a value to another job waiting on the given channel.  The result indicates whether a value was given or not.  Note that the other side of the communication must be blocked on the channel for communication to happen.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.Try.take" href="#dec:val Hopac.Ch.Try.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>option<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that attempts to take a value from another job waiting on the given channel.  Note that the other side of the communication must be blocked on the channel for communication to happen.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.IVar" href="#dec:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a write once variable.</p><p> Write once variables are designed for and most commonly used for getting replies from concurrent servers and asynchronous operations, but can also be useful for other purposes such as for one-shot events and for implementing incremental, but immutable, concurrent data structures.</p><p> Because it is common to need to be able to communicate either an expected successful result or an exceptional failure in typical use cases of write once variables, direct mechanisms are provided for both.  The implementation is optimized in such a way that the ability to report an exceptional failure does not add overhead to the expected successful usage scenarios.</p><p> Write once variables are lightweight objects and it is typical to always just create a new write once variable when one is needed.  In most cases, a write once variable will be slightly more lightweight than a channel.  This is possible because write once variables do not support simple rendezvous like channels do.  When simple rendezvous is necessary, a channel should be used instead.</p><p> Note that <code><a href="#def:type Hopac.IVar">IVar</a></code> is a subtype of <code><a href="#def:type Hopac.Promise">Promise</a></code> and <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:val Hopac.IVar.read">read</a>&nbsp;xI</code> is equivalent to <code>xI&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code>.</div>
<pre><b>module</b> <a id="def:module Hopac.IVar" href="#dec:module Hopac.IVar">IVar</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on write once variables.<pre><b>module</b> <a id="def:module Hopac.IVar.Now" href="#dec:module Hopac.IVar.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on write once variables.<pre><b>val</b> <a id="def:val Hopac.IVar.Now.create" href="#dec:val Hopac.IVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.Now.createFull" href="#dec:val Hopac.IVar.Now.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable with the given value.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.Now.createFailure" href="#dec:val Hopac.IVar.Now.createFailure">createFailure</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable with the given failure exception.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.Now.isFull" href="#dec:val Hopac.IVar.Now.isFull">isFull</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> bool
</pre>
<div class="nested"><p> Returns true iff the given write once variable has already been filled (either with a value or with a failure).</p><p> This operation is mainly provided for advanced uses of write once variables such as when creating more complex data structures that make internal use of write once variables.  Using this to poll write once variables is not generally a good idea.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.Now.get" href="#dec:val Hopac.IVar.Now.get">get</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Returns the value or raises the failure exception written to the write once variable.  It is considered an error if the write once variable has not yet been written to.</p><p> This operation is mainly provided for advanced uses of write once variables such as when creating more complex data structures that make internal use of write once variables.  Using this to poll write once variables is not generally a good idea.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.create" href="#dec:val Hopac.IVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new write once variable.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.fill" href="#dec:val Hopac.IVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given value to the given write once variable.  It is an error to write to a single write once variable more than once.  This assumption may be used to optimize the implementation of <code><a href="#def:val Hopac.IVar.fill">fill</a></code> and incorrect usage leads to undefined behavior.</p><p> In most use cases of write once variables the write once assumption naturally follows from the property that there is only one concurrent job that may ever write to a particular write once variable.  If that is not the case, then you should likely use some other communication primitive. See also: <code><a href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a></code>, <code><a href="#def:val Hopac.IVar.tryFill">tryFill</a></code>, <code><a href="#def:val Hopac.IVar.fillFailure">fillFailure</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.tryFill" href="#dec:val Hopac.IVar.tryFill">tryFill</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that tries to write the given value to the given write once variable.  No operation takes places and no error is reported in case the write once variable has already been written to.</p><p> In most use cases of write once variables it should be clear that a particular variable is written to at most once, because there is only one specific concurrent job that may write to the variable, and <code><a href="#def:val Hopac.IVar.tryFill">tryFill</a></code> should not be used as a substitute for not understanding how the program behaves.  However, in some case it can be convenient to use a write once variable as a single shot event and there may be several concurrent jobs that initially trigger the event.  In such cases, you may use <code><a href="#def:val Hopac.IVar.tryFill">tryFill</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.fillFailure" href="#dec:val Hopac.IVar.fillFailure">fillFailure</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given exception to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  See also: <code><a href="#def:val Hopac.Infixes.&lt;-=!">&lt;-=!</a></code>, <code><a href="#def:val Hopac.IVar.fill">fill</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.read" href="#dec:val Hopac.IVar.read">read</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available after the write once variable has been written to.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Latch" href="#dec:type Hopac.Latch">Latch</a> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Represents a dynamic latch.</p><p> Both a first-order interface, with <code>create</code>, <code><a href="#def:val Hopac.Latch.Now.increment">increment</a></code> and <code><a href="#def:val Hopac.Latch.decrement">decrement</a></code> operations, and a higher-order interface, with <code><a href="#def:val Hopac.Latch.within">within</a></code>, <code><a href="#def:val Hopac.Latch.holding">holding</a></code>, <code>queue</code> and <code>queueAsAlt</code> operations, are provided for programming with latches.</div>
<pre><b>module</b> <a id="def:module Hopac.Latch" href="#dec:module Hopac.Latch">Latch</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on latches.<pre><b>val</b> <a id="def:val Hopac.Latch.within" href="#dec:val Hopac.Latch.within">within</a><b>:</b> (<a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new latch, passes it to the given function to create a new job to run and then awaits for the latch to open.</div>
<pre><b>val</b> <a id="def:val Hopac.Latch.holding" href="#dec:val Hopac.Latch.holding">holding</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job holding the specified latch.  Note that the latch is only held while the given job is being run.  See also <code><a href="#def:module Hopac.Latch">Latch</a><b>.</b><a href="#def:val Hopac.Latch.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Latch.queue" href="#dec:val Hopac.Latch.queue">queue</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that queues the given job to run as a separate concurrent job and holds the latch until the queued job either returns or fails with an exception.  See also <code>Latch<b>.</b>queueAsAlt</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Latch.queueAsPromise" href="#dec:val Hopac.Latch.queueAsPromise">queueAsPromise</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that queues the given job to run as a separate concurrent job and holds the latch until the queued job either returns or fails with an exception.  A promise is returned for observing the result or failure of the queued job.</div>
<pre><b>module</b> <a id="def:module Hopac.Latch.Now" href="#dec:module Hopac.Latch.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate operations on latches.<pre><b>val</b> <a id="def:val Hopac.Latch.Now.create" href="#dec:val Hopac.Latch.Now.create">create</a><b>:</b> initial<b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Latch">Latch</a>
</pre>
<div class="nested"><p> Creates a new latch with the specified initial count.</div>
<pre><b>val</b> <a id="def:val Hopac.Latch.Now.increment" href="#dec:val Hopac.Latch.Now.increment">increment</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Increments the counter of the latch.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Latch.decrement" href="#dec:val Hopac.Latch.decrement">decrement</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that explicitly decrements the counter of the latch.  When the counter reaches <code>0</code>, the latch becomes open and operations awaiting the latch are resumed.</div>
<pre><b>val</b> <a id="def:val Hopac.Latch.await" href="#dec:val Hopac.Latch.await">await</a><b>:</b> <a href="#def:type Hopac.Latch">Latch</a> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns an alternative that becomes available once the latch opens.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.MVar" href="#dec:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a serialized variable.</p><p> You can use serialized variables to serialize access to a specific piece of shared state.  The idea is that one and only one concurrent job has access to that state at any one time.  This way access to the shared state is entirely serialized.</p><p> WARNING: Unfortunately, <code><a href="#def:type Hopac.MVar">MVar</a></code>s are easy to use unsafely.  Do not use an <code><a href="#def:type Hopac.MVar">MVar</a></code> to pass information from a client to a server, for example.  Use a <code><a href="#def:type Hopac.Ch">Ch</a></code> or <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code> for that.  Note that if you are familiar with the <code><a href="#def:type Hopac.MVar">MVar</a></code> abstraction provided by Concurrent Haskell, then it is important to realize that the semantics and intended usage of Hopac's and Concurrent ML's <code><a href="#def:type Hopac.MVar">MVar</a></code> are quite different.  The <code><a href="#def:type Hopac.MVar">MVar</a></code> of Concurrent Haskell is a bit like a simplified <code><a href="#def:type Hopac.Ch">Ch</a></code> with a buffer of one element and some additional operations. The <code><a href="#def:type Hopac.MVar">MVar</a></code> of Hopac and Concurrent ML does not allow usage as a kind of buffered channel.</p><p> A serialized variable can be either empty or full.  When a job makes an attempt to take the value of an empty variable, the job is suspended until some other job fills the variable with a value.  At any one time there should only be at most one job that holds the state to be written to a serialized variable.  Indeed, the idea is that access to that state is serialized.  If this cannot be guaranteed, in other words, there might be two or more jobs trying to fill a serialized variable, then you should not be using serialized variables.</p><p> Another way to put it is that serialized variables are designed to be used in such a way that the variable acts as a mechanism for passing a permission token, the value contained by the variable, from one concurrent job to another.  Only the concurrent job that holds the token is allowed to fill the variable.  When used in this way, operations on the variable appear as atomic and access to the state will be serialized.</p><p> In general, aside from a possible initial <code>fill</code> operation, an access to a serialized variable should be of the form <code>take&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>...</b>&nbsp;fill</code> or of the form <code>read</code>.  On the other hand, accesses of the form <code>fill</code> and <code>read&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;<b>...</b>&nbsp;fill</code> are unsafe.  A <code>take</code> operation effectively grants permission to the job to access the shared state.  The <code>fill</code> operation then gives that permission to the next job that wants to access the shared state.</p><p> Here is an implementation of a synchronization object similar to the .Net <code>AutoResetEvent</code> using serialized variables:</p><pre><b>type</b> AutoResetEvent (<a href="#def:val Hopac.Stream.init">init</a><b>:</b> bool) <b>=</b>
  <b>let</b> <a href="#def:val Hopac.Stream.Var.set">set</a> <b>=</b> <b>if</b> <a href="#def:val Hopac.Stream.init">init</a> <b>then</b> <a href="#def:val Hopac.TopLevel.mvarFull">mvarFull</a> () <b>else</b> <a href="#def:val Hopac.TopLevel.mvar">mvar</a> ()
  <b>let</b> unset <b>=</b> <b>if</b> <a href="#def:val Hopac.Stream.init">init</a> <b>then</b> <a href="#def:val Hopac.TopLevel.mvar">mvar</a> () <b>else</b> <a href="#def:val Hopac.TopLevel.mvarFull">mvarFull</a> ()
  <b>member</b> this<b>.</b>Set <b>=</b> unset <a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a> <a href="#def:val Hopac.Stream.Var.set">set</a> <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:val Hopac.MVar.fill">fill</a> <a href="#def:val Hopac.Stream.Var.set">set</a>
  <b>member</b> this<b>.</b>Wait <b>=</b> <a href="#def:val Hopac.Stream.Var.set">set</a> <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:val Hopac.MVar.fill">fill</a> unset
</pre><p> The idea is to use two serialized variables to represent the state of the synchronization object.  At most one of the variables, representing the state of the synchronization object, is full at any time.</p><p> Note that <code><a href="#def:type Hopac.MVar">MVar</a></code> is a subtype of <code><a href="#def:type Hopac.Alt">Alt</a></code> and <code>xM&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is equivalent to <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:val Hopac.MVar.take">take</a>&nbsp;xM</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.MVar" href="#dec:module Hopac.MVar">MVar</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on serialized variables.<pre><b>module</b> <a id="def:module Hopac.MVar.Now" href="#dec:module Hopac.MVar.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on serialized variables.<pre><b>val</b> <a id="def:val Hopac.MVar.Now.create" href="#dec:val Hopac.MVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new serialized variable that is initially empty.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.Now.createFull" href="#dec:val Hopac.MVar.Now.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new serialized variable that initially contains the given value.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.create" href="#dec:val Hopac.MVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new serialized variable that is initially empty.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.createFull" href="#dec:val Hopac.MVar.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new serialized variable that initially contains the given value.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.fill" href="#dec:val Hopac.MVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given value to the serialized variable.  It is an error to write to a <code><a href="#def:type Hopac.MVar">MVar</a></code> that is full.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  See also: <code><a href="#def:val Hopac.Infixes.&lt;&lt;-=">&lt;&lt;-=</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.modifyFun" href="#dec:val Hopac.MVar.modifyFun">modifyFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>*</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given function.</p><p> Note that this operation is not atomic as such.  However, it is a common programming pattern to make it so that only the job that has emptied an <code><a href="#def:type Hopac.MVar">MVar</a></code> by taking a value from it is allowed to fill the <code><a href="#def:type Hopac.MVar">MVar</a></code>.  Such an access pattern makes operations on the <code><a href="#def:type Hopac.MVar">MVar</a></code> appear as atomic.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.MVar.modifyFun">modifyFun</a> (x2xy<b>:</b> <i>'x</i> <b>-&gt;</b> <i>'x</i> <b>*</b> <i>'y</i>) (xM<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b>
  xM <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> (x2xy <b>&gt;&gt;</b> <b>fun</b> (x, y) <b>-&gt;</b> <a href="#def:val Hopac.MVar.fill">fill</a> xM x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a> y)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.MVar.modifyJob" href="#dec:val Hopac.MVar.modifyJob">modifyJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that takes the value of the serialized variable and then fills the variable with the result of performing the given job.</p><p> Note that this operation is not atomic as such.  However, it is a common programming pattern to make it so that only the job that has emptied an <code><a href="#def:type Hopac.MVar">MVar</a></code> by taking a value from it is allowed to fill the <code><a href="#def:type Hopac.MVar">MVar</a></code>.  Such an access pattern makes operations on the <code><a href="#def:type Hopac.MVar">MVar</a></code> appear as atomic.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.MVar.modifyJob">modifyJob</a> (x2xyJ<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>) (xM<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b>
  xM <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <b>fun</b> x <b>-&gt;</b> x2xyJ x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> (x, y) <b>-&gt;</b> <a href="#def:val Hopac.MVar.fill">fill</a> xM x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a> y
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.MVar.read" href="#dec:val Hopac.MVar.read">read</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available when the variable contains a value and, if committed to, read the value from the variable.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.MVar.read">read</a> xM <b>=</b> <a href="#def:val Hopac.MVar.take">take</a> xM <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a> <b>fun</b> x <b>-&gt;</b> <a href="#def:val Hopac.MVar.fill">fill</a> xM x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a> x
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.MVar.take" href="#dec:val Hopac.MVar.take">take</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available when the variable contains a value and, if committed to, takes the value from the variable.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Mailbox" href="#dec:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents an asynchronous, unbounded buffered mailbox.</p><p> Compared to channels, mailboxes take more memory when empty, but offer space efficient buffering of messages.  In situations where buffering must be bounded, a bounded mailbox, <code><a href="#def:type Hopac.BoundedMb">BoundedMb</a><b>&lt;</b>_<b>&gt;</b></code>, should be preferred.  In situations where buffering is not needed, a channel, <code><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b>_<b>&gt;</b></code>, should be preferred.</p><p> Note that <code><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is a subtype of <code><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> and <code>xMb&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is equivalent to <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:val Hopac.Mailbox.take">take</a>&nbsp;xMb</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Mailbox" href="#dec:module Hopac.Mailbox">Mailbox</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on buffered mailboxes.<pre><b>module</b> <a id="def:module Hopac.Mailbox.Now" href="#dec:module Hopac.Mailbox.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on buffered mailboxes.<pre><b>val</b> <a id="def:val Hopac.Mailbox.Now.create" href="#dec:val Hopac.Mailbox.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new mailbox.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Mailbox.Global" href="#dec:module Hopac.Mailbox.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations bound to the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Mailbox.Global.send" href="#dec:val Hopac.Mailbox.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sends the given value to the specified mailbox.  <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:module Hopac.Mailbox.Global">Global</a><b>.</b><a href="#def:val Hopac.Mailbox.Global.send">send</a>&nbsp;xMb&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:val Hopac.Mailbox.send">send</a>&nbsp;xMb&nbsp;x&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.start">start</a></code>.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:val Hopac.Mailbox.send">send</a></code> instead.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Mailbox.create" href="#dec:val Hopac.Mailbox.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new mailbox.</div>
<pre><b>val</b> <a id="def:val Hopac.Mailbox.send" href="#dec:val Hopac.Mailbox.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends the given value to the specified mailbox.  This operation never blocks.  See also: <code><a href="#def:val Hopac.Infixes.&lt;&lt;-+">&lt;&lt;-+</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Mailbox.take" href="#dec:val Hopac.Mailbox.take">take</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available when the mailbox contains at least one value and, if committed to, takes a value from the mailbox.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Promise" href="#dec:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a promise to produce a result at some point in the future.</p><p> Promises are used when a parallel job is started for the purpose of computing a result.  When multiple parallel jobs need to be started to compute results in parallel in regular patterns, combinators such as <code><a href="#def:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a></code>, <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.conCollect">conCollect</a></code> and <code><a href="#def:module Hopac.Extensions.Seq">Seq</a><b>.</b><a href="#def:module Hopac.Extensions.Seq.Con">Con</a><b>.</b><a href="#def:val Hopac.Extensions.Seq.Con.mapJob">mapJob</a></code> may be easier to use and provide improved performance.</div>
<pre><b>module</b> <a id="def:module Hopac.Promise" href="#dec:module Hopac.Promise">Promise</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on promises.<pre><b>module</b> <a id="def:module Hopac.Promise.Now" href="#dec:module Hopac.Promise.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on promises.<pre><b>val</b> <a id="def:val Hopac.Promise.Now.delay" href="#dec:val Hopac.Promise.Now.delay">delay</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a promise whose value is computed lazily with the given job when an attempt is made to read the promise.  Although the job is not started immediately, the effect is that the delayed job will be run as a separate job, which means it is possible to communicate with it as long the delayed job is started before trying to communicate with it.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.Now.withValue" href="#dec:val Hopac.Promise.Now.withValue">withValue</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a promise with the given value.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.Now.withFailure" href="#dec:val Hopac.Promise.Now.withFailure">withFailure</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a promise with the given failure exception.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.Now.isFulfilled" href="#dec:val Hopac.Promise.Now.isFulfilled">isFulfilled</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> bool
</pre>
<div class="nested"><p> Returns true iff the given promise has already been fulfilled (either with a value or with a failure).</p><p> This operation is mainly provided for advanced uses of promises such as when creating more complex data structures that make internal use of promises.  Using this to poll promises is not generally a good idea.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.Now.get" href="#dec:val Hopac.Promise.Now.get">get</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Returns the value or raises the failure exception that the promise has been fulfilled with.  It is considered an error if the promise has not yet been fulfilled.</p><p> This operation is mainly provided for advanced uses of promises such as when creating more complex data structures that make internal use of promises.  Using this to poll promises is not generally a good idea.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Promise.Infixes" href="#dec:module Hopac.Promise.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Infix operators on promises.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes.&lt;|&gt;*" href="#dec:val Hopac.Promise.Infixes.&lt;|&gt;*">&lt;|&gt;*</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;?">&lt;|&gt;?</a></code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes.&gt;&gt;=*" href="#dec:val Hopac.Promise.Infixes.&gt;&gt;=*">&gt;&gt;=*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a></code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes.&gt;&gt;.*" href="#dec:val Hopac.Promise.Infixes.&gt;&gt;.*">&gt;&gt;.*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a></code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes..&gt;&gt;*" href="#dec:val Hopac.Promise.Infixes..&gt;&gt;*">.&gt;&gt;*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Job.Infixes..&gt;&gt;">.&gt;&gt;</a></code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes.|&gt;&gt;*" href="#dec:val Hopac.Promise.Infixes.|&gt;&gt;*">|&gt;&gt;*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a></code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes.&gt;&gt;%*" href="#dec:val Hopac.Promise.Infixes.&gt;&gt;%*">&gt;&gt;%*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a></code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Promise.Infixes.&gt;&gt;!*" href="#dec:val Hopac.Promise.Infixes.&gt;&gt;!*">&gt;&gt;!*</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> A memoizing version of <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a></code>.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.start" href="#dec:val Hopac.Promise.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a promise, whose value is computed with the given job, which is immediately started to run as a separate concurrent job.  See also: <code><a href="#def:val Hopac.Promise.queue">queue</a></code>, <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.queue" href="#dec:val Hopac.Promise.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a promise, whose value is computed with the given job, which is scheduled to be run as a separate concurrent job.  See also: <code><a href="#def:val Hopac.Promise.start">start</a></code>, <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.read" href="#dec:val Hopac.Promise.read">read</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative for reading the promise.  If the promise was delayed, it is started as a separate job.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Lock" href="#dec:type Hopac.Lock">Lock</a>
</pre>
<div class="nested"><p> A non-recursive mutual exclusion lock for jobs.</p><p> In most cases you should use higher-level message passing primitives such as <code><a href="#def:type Hopac.Ch">Ch</a></code>, <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code>, <code><a href="#def:type Hopac.MVar">MVar</a></code> or <code><a href="#def:type Hopac.IVar">IVar</a></code>, but in some cases a simple lock might be more natural to use.</p><p> Note that this lock is for synchronizing at the level of jobs.  A job may even block while holding the lock.  For short non-blocking critical sections, native locks (e.g. <code>Monitor</code> and <code>SpinLock</code>), concurrent data structures or interlocked operations should be faster.  On the other hand, suspending and resuming a job is several orders of magnitude faster than suspending and resuming a native thread.</div>
<pre><b>module</b> <a id="def:module Hopac.Lock" href="#dec:module Hopac.Lock">Lock</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on mutual exclusion locks.<pre><b>module</b> <a id="def:module Hopac.Lock.Now" href="#dec:module Hopac.Lock.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on locks.<pre><b>val</b> <a id="def:val Hopac.Lock.Now.create" href="#dec:val Hopac.Lock.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Lock">Lock</a>
</pre>
<div class="nested"><p> Creates a new lock.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Lock.create" href="#dec:val Hopac.Lock.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Lock">Lock</a><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new mutual exclusion lock.</div>
<pre><b>val</b> <a id="def:val Hopac.Lock.duringFun" href="#dec:val Hopac.Lock.duringFun">duringFun</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function so that the lock is held during the execution of the function.</div>
<pre><b>val</b> <a id="def:val Hopac.Lock.duringJob" href="#dec:val Hopac.Lock.duringJob">duringJob</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job so that the lock is held during the execution of the given job.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Extensions" href="#dec:module Hopac.Extensions">Extensions</a> <b>=</b>
</pre>
<div class="nested"><p> Extensions to various system modules and types for programming with jobs. You can open this module to use the extensions much like as if they were part of the existing modules and types.<pre><b>module</b> <a id="def:module Hopac.Extensions.Array" href="#dec:module Hopac.Extensions.Array">Array</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for processing arrays with jobs.<pre><b>val</b> <a id="def:val Hopac.Extensions.Array.mapJob" href="#dec:val Hopac.Extensions.Array.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>array<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Sequentially maps the given job constructor to the elements of the array and returns an array of the results.  <code><a href="#def:module Hopac.Extensions.Array">Array</a><b>.</b><a href="#def:val Hopac.Extensions.Array.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs</code> is an optimized version of <code><a href="#def:module Hopac.Extensions.Seq">Seq</a><b>.</b><a href="#def:val Hopac.Extensions.Seq.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>&nbsp;<b>fun</b>&nbsp;ys&nbsp;<b>-&gt;</b>&nbsp;ys<b>.</b>ToArray&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Array.iterJob" href="#dec:val Hopac.Extensions.Array.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Sequentially iterates the given job constructor over the given array. <code><a href="#def:module Hopac.Extensions.Array">Array</a><b>.</b><a href="#def:val Hopac.Extensions.Array.iterJob">iterJob</a>&nbsp;x2uJ&nbsp;xs</code> is an optimized version of <code><a href="#def:module Hopac.Extensions.Seq">Seq</a><b>.</b><a href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a>&nbsp;x2uJ&nbsp;xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Array.iterJobIgnore" href="#dec:val Hopac.Extensions.Array.iterJobIgnore">iterJobIgnore</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Extensions.Array.iterJobIgnore">iterJobIgnore</a>&nbsp;x2yJ&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Extensions.Array.iterJob">iterJob</a>&nbsp;(x2yJ&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>)&nbsp;xs</code>.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Extensions.Seq" href="#dec:module Hopac.Extensions.Seq">Seq</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for processing sequences with jobs.<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.iterJob" href="#dec:val Hopac.Extensions.Seq.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Sequentially iterates the given job constructor over the given sequence.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a> x2uJ (xs<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.using">using</a> (xs<b>.</b>GetEnumerator ()) <b>&lt;|</b> <b>fun</b> xs <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    x2uJ xs<b>.</b>Current)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.iterJobIgnore" href="#dec:val Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Extensions.Seq.iterJobIgnore">iterJobIgnore</a>&nbsp;x2yJ&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a>&nbsp;(x2yJ&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>)&nbsp;xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.mapJob" href="#dec:val Hopac.Extensions.Seq.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Sequentially maps the given job constructor to the elements of the sequence and returns a list of the results.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Extensions.Seq.mapJob">mapJob</a> x2yJ (xs<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> ys <b>=</b> ResizeArray<b>&lt;</b>_<b>&gt;</b>()
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.using">using</a> (xs<b>.</b>GetEnumerator ()) <b>&lt;|</b> <b>fun</b> xs <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    x2yJ xs<b>.</b>Current <a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a> ys<b>.</b>Add) <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>
  ys
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.foldJob" href="#dec:val Hopac.Extensions.Seq.foldJob">foldJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> seq<b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Sequentially folds the job constructor over the given sequence and returns the result of the fold.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Extensions.Seq.foldJob">foldJob</a> xy2xJ x (ys<b>:</b> seq<b>&lt;</b><i>'y</i><b>&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.using">using</a> (ys<b>.</b>GetEnumerator ()) <b>&lt;|</b> <b>fun</b> ys <b>-&gt;</b>
  <b>let</b> <b>rec</b> loop x <b>=</b>
    <b>if</b> ys<b>.</b>MoveNext () <b>then</b>
      xy2xJ x ys<b>.</b>Current <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> loop
    <b>else</b>
      <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.result">result</a> x
  loop x
</pre></div>
<pre><b>module</b> <a id="def:module Hopac.Extensions.Seq.Con" href="#dec:module Hopac.Extensions.Seq.Con">Con</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for processing sequences using concurrent jobs.<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.Con.iterJob" href="#dec:val Hopac.Extensions.Seq.Con.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Iterates the given job constructor over the given sequence, runs the constructed jobs as separate concurrent jobs and waits until all of the jobs have finished.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.Con.iterJobIgnore" href="#dec:val Hopac.Extensions.Seq.Con.iterJobIgnore">iterJobIgnore</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code>iterJobIgnore&nbsp;x2yJ&nbsp;xs</code> is equivalent to <code>iterJob&nbsp;(x2yJ&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>)&nbsp;xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.Con.mapJob" href="#dec:val Hopac.Extensions.Seq.Con.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Iterates the given job constructor over the given sequence, runs the constructed jobs as separate concurrent jobs and waits until all of the jobs have finished collecting the results into a list.</div>
</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Extensions.Async" href="#dec:module Hopac.Extensions.Async">Async</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for interfacing F# async operations with jobs.</p><p> Note that these operations are provided for interfacing with existing APIs that work with async operations.  Running async operations within jobs and vice versa incurs potentially significant overheads.</p><p> Note that there is almost a one-to-one mapping between async operations and jobs.  The main semantic difference between async operations and Hopac jobs is the threads and schedulers they are being executed on.<pre><b>val</b> <a id="def:val Hopac.Extensions.Async.toJob" href="#dec:val Hopac.Extensions.Async.toJob">toJob</a><b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts the given async operation and then waits until the operation finishes.</p><p> The async operation will be started on a Hopac worker thread, which means that the async operation will continue on the thread pool. Consider whether you need to call <code>Async<b>.</b>SwitchToContext</code> or some other thread or synchronization context switching async operation in your async operation.  See also: <code><a href="#def:val Hopac.Extensions.Async.toJobOn">toJobOn</a></code>, <code><a href="#def:val Hopac.Extensions.Async.toAlt">toAlt</a></code>, <code><a href="#def:val Hopac.Extensions.Async.toAltOn">toAltOn</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Async.toJobOn" href="#dec:val Hopac.Extensions.Async.toJobOn">toJobOn</a><b>:</b> SynchronizationContext <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that posts the given async operation to the specified synchronization context for execution and then waits until the operation finishes.  As a special case, <code><a href="#def:val Hopac.Extensions.Async.toJobOn">toJobOn</a>&nbsp;null&nbsp;xA</code> is equivalent to <code><a href="#def:val Hopac.Extensions.Async.toJob">toJob</a>&nbsp;xA</code>.  See also: <code><a href="#def:val Hopac.Extensions.Async.toAlt">toAlt</a></code>, <code><a href="#def:val Hopac.Extensions.Async.toAltOn">toAltOn</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Async.toAlt" href="#dec:val Hopac.Extensions.Async.toAlt">toAlt</a><b>:</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, when instantiated, starts the given async operation and then becomes enabled once the operation finishes. Furthermore, in case the alternative is not committed to, the async operation is cancelled.</p><p> The async operation will be started on a Hopac worker thread, which means that the async operation will continue on the thread pool. Consider whether you need to call <code>Async<b>.</b>SwitchToContext</code> or some other thread or synchronization context switching async operation in your async operation.  See also: <code><a href="#def:val Hopac.Extensions.Async.toJob">toJob</a></code>, <code><a href="#def:val Hopac.Extensions.Async.toJobOn">toJobOn</a></code>, <code><a href="#def:val Hopac.Extensions.Async.toAltOn">toAltOn</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Async.toAltOn" href="#dec:val Hopac.Extensions.Async.toAltOn">toAltOn</a><b>:</b> SynchronizationContext <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, when instantiated, posts the given async operation to the specified synchronization context for execution and then becomes enabled once the operation finishes.  Furthermore, in case the alternative is not committed to, the async operation is cancelled. As a special case, <code><a href="#def:val Hopac.Extensions.Async.toAltOn">toAltOn</a>&nbsp;null&nbsp;xA</code> is equivalent to <code><a href="#def:val Hopac.Extensions.Async.toAlt">toAlt</a>&nbsp;xA</code>.  See also: <code><a href="#def:val Hopac.Extensions.Async.toJob">toJob</a></code>, <code><a href="#def:val Hopac.Extensions.Async.toJobOn">toJobOn</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Async.ofJobOn" href="#dec:val Hopac.Extensions.Async.ofJobOn">ofJobOn</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an async operation that starts the given job on the specified scheduler and then waits until the started job finishes.  See also: <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.scheduler">scheduler</a></code>, <code><a href="#def:module Hopac.Extensions.Async">Async</a><b>.</b><a href="#def:module Hopac.Extensions.Async.Global">Global</a><b>.</b><a href="#def:val Hopac.Extensions.Async.Global.ofJob">ofJob</a></code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Extensions.Async.Global" href="#dec:module Hopac.Extensions.Async.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Extensions.Async.Global.ofJob" href="#dec:val Hopac.Extensions.Async.Global.ofJob">ofJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an async operation that starts the given job on the global scheduler and then waits until the started job finishes.  See also: <code><a href="#def:module Hopac.Extensions.Async">Async</a><b>.</b><a href="#def:val Hopac.Extensions.Async.ofJobOn">ofJobOn</a></code>.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Extensions.Async.OnWithSchedulerBuilder" href="#dec:type Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a> <b>=</b>
</pre>
<div class="nested"><p> Builder for async workflows.  The methods in this builder delegate to the default <code>async</code> builder.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.asyncOn" href="#dec:val Hopac.Extensions.asyncOn">asyncOn</a><b>:</b> SynchronizationContext
          <b>-&gt;</b> Scheduler
          <b>-&gt;</b> <a href="#def:module Hopac.Extensions.Async">Async</a><b>.</b><a href="#def:type Hopac.Extensions.Async.OnWithSchedulerBuilder">OnWithSchedulerBuilder</a>
</pre>
<div class="nested"><p> Builder for an async operation started on the given synchronization context with jobs on the specified scheduler wrapped as a job.</div>
<pre><b>type</b> <a id="def:type Hopac.Extensions.Task" href="#dec:type Hopac.Extensions.Task">Task</a> <b>with</b>
</pre>
<div class="nested"><p> Operations for interfacing tasks with jobs.</p><p> Note that these operations are provided for interfacing with existing APIs that work with tasks.  Starting a job as a task and then awaiting for its result has much higher overhead than simply starting the job as a <code><a href="#def:type Hopac.Promise">Promise</a></code>, for example.</p><p> Note that starting tasks correctly can be tricky.  Hopac jobs are designed to be executed by Hopac worker threads, which have the default <code>null</code> synchronization context like the .Net thread pool, but Hopac jobs can also be started on other threads, which may live in non-default synchronization contexts.  Tasks that have been written using the C# async-await mechanism may capture the current synchronization context.  This means that when you call a function to start a task within a Hopac job, you may need to explicitly post that function call to a specific synchronization context.</p><p> Note that tasks and jobs are quite different in nature as tasks are comonadic while jobs are monadic.<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.awaitJob" href="#dec:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits for the given task to finish and then returns the result of the task.  Note that this does not start the task.  Make sure that the task is started correctly.</p><p> Reference implementation:</p><pre><b>let</b> awaitJob (xT<b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.scheduler">scheduler</a> () <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>fun</b> sr <b>-&gt;</b>
  <b>let</b> xI <b>=</b> <a href="#def:val Hopac.TopLevel.ivar">ivar</a> ()
  xT<b>.</b>ContinueWith (Action<b>&lt;</b>Threading<b>.</b>Tasks<b>.</b><a href="#def:type Hopac.Extensions.Task">Task</a><b>&gt;</b>(<b>fun</b> _ <b>-&gt;</b>
    <a href="#def:module Hopac.Scheduler">Scheduler</a><b>.</b><a href="#def:val Hopac.Scheduler.start">start</a> sr (<b>try</b> xI <a href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a> xT<b>.</b>Result <b>with</b> e <b>-&gt;</b> xI <a href="#def:val Hopac.Infixes.&lt;-=!">&lt;-=!</a> e)))
  <b>|&gt;</b> ignore
  <b>upcast</b> xI
</pre></div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.awaitJob" href="#dec:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits until the given task finishes.  Note that this does not start the task.  Make sure that the task is started correctly.</div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.bindJob" href="#dec:static member Hopac.Extensions.Task.bindJob">bindJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>bindJob&nbsp;(xT,&nbsp;x2yJ)</code> is equivalent to <code>awaitJob&nbsp;xT&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;x2yJ</code>.</div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.bindJob" href="#dec:static member Hopac.Extensions.Task.bindJob">bindJob</a><b>:</b> <a href="#def:type Hopac.Extensions.Task">Task</a> <b>*</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>bindJob&nbsp;(uT,&nbsp;u2xJ)</code> is equivalent to <code>awaitJob&nbsp;uT&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>&nbsp;u2xJ</code>.</div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.startJob" href="#dec:static member Hopac.Extensions.Task.startJob">startJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Extensions.Task">Task</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts the given job as a separate concurrent job, whose result can be obtained from the returned task.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Scheduler" href="#dec:type Hopac.Scheduler">Scheduler</a>
</pre>
<div class="nested"><p> Represents a scheduler that manages a number of worker threads.</div>
<pre><b>module</b> <a id="def:module Hopac.Scheduler" href="#dec:module Hopac.Scheduler">Scheduler</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on schedulers.  Use of this module requires more intimate knowledge of Hopac, but may allow adapting Hopac to special application requirements.<pre><b>type</b> <a id="def:type Hopac.Scheduler.Create" href="#dec:type Hopac.Scheduler.Create">Create</a> <b>=</b>
</pre>
<div class="nested"><p> A record of scheduler configuration options.<pre><a id="def:field Hopac.Scheduler.Create.Foreground" href="#dec:field Hopac.Scheduler.Create.Foreground">Foreground</a><b>:</b> option<b>&lt;</b>bool<b>&gt;</b>
</pre>
<div class="nested"><p> Specifies whether worker threads are run as background threads or as foreground threads.  The default is to run workers as background threads.  If you want to run worker threads as foreground threads, then you will have to explicitly kill the worker threads.  Using foreground threads is probably preferable if your application dynamically creates and kills local schedulers to make sure the worker threads are properly killed.</div>
<pre><a id="def:field Hopac.Scheduler.Create.IdleHandler" href="#dec:field Hopac.Scheduler.Create.IdleHandler">IdleHandler</a><b>:</b> option<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>int<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Specifies the idle handler for workers.  The worker idle handler is run whenever an individual worker runs out of work.  The idle handler must return an integer value that specifies how many milliseconds the worker is allowed to sleep.  <code>Timeout<b>.</b>Infinite</code> puts the worker into sleep until the scheduler explicitly wakes it up.  <code>0</code> means that the idle handler found some new work and the worker should immediately look for it.</div>
<pre><a id="def:field Hopac.Scheduler.Create.MaxStackSize" href="#dec:field Hopac.Scheduler.Create.MaxStackSize">MaxStackSize</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
</pre>
<div class="nested"><p> Specifies the maximum stack size for worker threads.  The default is to use the default maximum stack size of the <code>Thread</code> class.</div>
<pre><a id="def:field Hopac.Scheduler.Create.NumWorkers" href="#dec:field Hopac.Scheduler.Create.NumWorkers">NumWorkers</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
</pre>
<div class="nested"><p> Number of worker threads.  Using more than <code>Environment<b>.</b>ProcessorCount</code> is not optimal and may, in some cases, significantly reduce performance.  The default is <code>Environment<b>.</b>ProcessorCount</code>.</div>
<pre><a id="def:field Hopac.Scheduler.Create.TopLevelHandler" href="#dec:field Hopac.Scheduler.Create.TopLevelHandler">TopLevelHandler</a><b>:</b> option<b>&lt;</b>exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Specifies the top level exception handler job constructor of the scheduler.  When a job fails with an otherwise unhandled exception, the job is killed and a new job is constructed with the top level handler constructor and then started.  To avoid infinite loops, in case the top level handler job raises exceptions, it is simply killed after printing a message to the console.  The default top level handler simply prints out a message to the console.</div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Scheduler.Create.Def" href="#dec:static member Hopac.Scheduler.Create.Def">Def</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a>
</pre>
<div class="nested"><p> Default options.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Scheduler.Global" href="#dec:module Hopac.Scheduler.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Scheduler.Global.setCreate" href="#dec:val Hopac.Scheduler.Global.setCreate">setCreate</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sets options for creating the global scheduler.  This must be called before invoking any Hopac functionality that implicitly creates the global scheduler.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.create" href="#dec:val Hopac.Scheduler.create">create</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a> <b>-&gt;</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
</pre>
<div class="nested"><p> Creates a new local scheduler.</p><p> Note that a local scheduler does not automatically implement services such as the global wall-clock timer.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.startWithActions" href="#dec:val Hopac.Scheduler.startWithActions">startWithActions</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
                   <b>-&gt;</b> (exn <b>-&gt;</b> unit)
                   <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit)
                   <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job, but does not wait for the job to finish. Upon the failure or success of the job, one of the given actions is called once.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</p><p> Note that using this function in a job workflow is not optimal and you should instead use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> with desired Job exception handling construct (e.g. <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> or <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.catch">catch</a></code>).</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.start" href="#dec:val Hopac.Scheduler.start">start</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job, but does not wait for the job to finish.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.startIgnore" href="#dec:val Hopac.Scheduler.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Scheduler.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Scheduler.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.queue" href="#dec:val Hopac.Scheduler.queue">queue</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Queues the given job for execution on the scheduler.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.queueIgnore" href="#dec:val Hopac.Scheduler.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Scheduler.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Scheduler.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.server" href="#dec:val Hopac.Scheduler.server">server</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Like <code><a href="#def:module Hopac.Scheduler">Scheduler</a><b>.</b><a href="#def:val Hopac.Scheduler.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.wait" href="#dec:val Hopac.Scheduler.wait">wait</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Waits until the scheduler becomes completely idle.</p><p> Note that for this to make sense, the scheduler should be a local scheduler that your program manages explicitly.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.kill" href="#dec:val Hopac.Scheduler.kill">kill</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Kills the worker threads of the scheduler one-by-one.  This should only be used with a local scheduler that is known to be idle.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Infixes" href="#dec:module Hopac.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Additional infix operators.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;--" href="#dec:val Hopac.Infixes.&lt;--">&lt;--</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.  <code>xCh&nbsp;<a href="#def:val Hopac.Infixes.&lt;--">&lt;--</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.give">give</a>&nbsp;xCh&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-+" href="#dec:val Hopac.Infixes.&lt;-+">&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends a value to another job on the given channel.  A send operation is asynchronous.  In other words, a send operation does not wait for another job to give the value to.  <code>xCh&nbsp;<a href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a>&nbsp;xCh&nbsp;x</code>.</p><p> Note that channels have been optimized for synchronous operations; an occasional send can be efficient, but when sends are queued, performance maybe be significantly worse than with a <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code> optimized for buffering.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-=" href="#dec:val Hopac.Infixes.&lt;-=">&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code>xI&nbsp;<a href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:val Hopac.IVar.fill">fill</a>&nbsp;xI&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-=!" href="#dec:val Hopac.Infixes.&lt;-=!">&lt;-=!</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given exception to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code>xI&nbsp;<a href="#def:val Hopac.Infixes.&lt;-=!">&lt;-=!</a>&nbsp;e</code> is equivalent to <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:val Hopac.IVar.fillFailure">fillFailure</a>&nbsp;xI&nbsp;e</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;&lt;-=" href="#dec:val Hopac.Infixes.&lt;&lt;-=">&lt;&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given value to the serialized variable.  It is an error to write to a <code><a href="#def:type Hopac.MVar">MVar</a></code> that is full.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code>xM&nbsp;<a href="#def:val Hopac.Infixes.&lt;&lt;-=">&lt;&lt;-=</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:val Hopac.MVar.fill">fill</a>&nbsp;xM&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;&lt;-+" href="#dec:val Hopac.Infixes.&lt;&lt;-+">&lt;&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends the given value to the specified mailbox.  This operation never blocks.  <code>xMb&nbsp;<a href="#def:val Hopac.Infixes.&lt;&lt;-+">&lt;&lt;-+</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:val Hopac.Mailbox.send">send</a>&nbsp;xMb&nbsp;x</code>.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Stream" href="#dec:module Hopac.Stream">Stream</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on choice streams.<pre><b>type</b> <a id="def:type Hopac.Stream.Cons" href="#dec:type Hopac.Stream.Cons">Cons</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b>
  <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> of Value<b>:</b> <i>'x</i> <b>*</b> Next<b>:</b> Alt<b>&lt;</b><a href="#def:type Hopac.Stream.Cons">Cons</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>|</b> Nil
</pre>
<div class="nested"><p> Represents a point in a non-deterministic stream of values.</div>
<pre><b>type</b> <a id="def:type Hopac.Stream.Stream" href="#dec:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><a href="#def:type Hopac.Stream.Cons">Cons</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Represents a non-deterministic stream of values called a choice stream.</p><p> Choice streams can be used in ways similar to Rx observable sequences. However, the underlying implementations of choice streams and observable sequences are almost polar opposites: choice streams are pull based while obserable sequences are push based.</p><p> Probably the most notable advantage of observable sequences over choice streams is that observables support disposables via their subscription protocol.  Choice streams do not have a subscription protocol and cannot support disposables in the same manner.</p><p> On the other hand, choice streams offer several advantages over observable sequences:</p><p> - Choice streams are simple and allow consumers and producers to be written using simple programming techniques such as lexical binding, recursion and immutable data structures.  You can see many examples of this in the reference implementations of various stream combinators. Observable sequences can only be subscribed to by imperative callbacks. The implementation of choice streams is two orders of magnitude shorter than the implementation of .Net Rx.</p><p> - Choice streams are designed to be consistent in that they generate the same sequence of values for every consumer.  There are no hot and cold observables like with observable sequences.  Many trivial choice stream combinators, such as <code><a href="#def:val Hopac.Stream.tails">tails</a></code>, can be very challenging, if not impossible, to specify and implement meaningfully for observable sequences.</p><p> - Choice streams allow the use of asynchronous programming at any point. For example, <code><a href="#def:val Hopac.Stream.iterJob">iterJob</a></code> waits for the asynchronous job to finish before consuming the next value from the stream.  The <code>Subscribe</code> operation of observables cannot support such behavior, because <code>OnNext</code> calls are synchronous.</p><p> - Choice streams allow values to be generated both lazily in response to consumers and eagerly in response to producers.  Observable sequences can only be generated eagerly in response to producers.  For example, the <code><a href="#def:val Hopac.Stream.afterEach">afterEach</a></code> and <code><a href="#def:val Hopac.Stream.beforeEach">beforeEach</a></code> combinators cannot be implemented for observable sequences, because observables do not have a protocol for requesting elements one by one.</p><p> All of the above advantages are strongly related and result from the pull based nature of choice streams.</p><p> While the most common operations are very easy to implement on choice streams, some operations perhaps require more intricate programming than with push based models.  For example, <code><a href="#def:val Hopac.Stream.groupByFun">groupByFun</a></code> and <code><a href="#def:val Hopac.Stream.shift">shift</a></code>, that corresponds to <code>Delay</code> in Rx, are non-trivial, although both implementations are actually much shorter than their .Net Rx counterparts.</div>
<pre><b>type</b> <a id="def:type Hopac.Stream.Src" href="#dec:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents an imperative source of a stream of values called a stream source.</div>
<pre><b>module</b> <a id="def:module Hopac.Stream.Src" href="#dec:module Hopac.Stream.Src">Src</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on stream sources.<pre><b>val</b> <a id="def:val Hopac.Stream.Src.create" href="#dec:val Hopac.Stream.Src.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new stream source.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Src.value" href="#dec:val Hopac.Stream.Src.value">value</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Appends a new value to the end of the generated stream.  This operation is atomic and can be safely used from multiple parallel jobs.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Src.error" href="#dec:val Hopac.Stream.Src.error">error</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Terminates the stream with an error.  The given exception is raised in the consumers of the stream if and when they reach the end of the stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Src.close" href="#dec:val Hopac.Stream.Src.close">close</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Terminates the stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Src.tap" href="#dec:val Hopac.Stream.Src.tap">tap</a><b>:</b> <a href="#def:type Hopac.Stream.Src">Src</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns the remainder of the generated stream after the point in time when <code><a href="#def:val Hopac.Stream.Src.tap">tap</a></code> is called.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Stream.Var" href="#dec:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a mutable variable, called a stream variable, that generates a stream of values as a side-effect.</div>
<pre><b>module</b> <a id="def:module Hopac.Stream.Var" href="#dec:module Hopac.Stream.Var">Var</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on stream variables.<pre><b>val</b> <a id="def:val Hopac.Stream.Var.create" href="#dec:val Hopac.Stream.Var.create">create</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new stream variable.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Var.get" href="#dec:val Hopac.Stream.Var.get">get</a><b>:</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Gets the value of the variable.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Var.set" href="#dec:val Hopac.Stream.Var.set">set</a><b>:</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Sets the value of the variable and appends the value to the end of the generated stream.  Note that while this operation is atomic, and can be safely used from multiple parallel jobs, a combination of <code><a href="#def:val Hopac.Stream.Var.get">get</a></code> and <code><a href="#def:val Hopac.Stream.Var.set">set</a></code> is not atomic.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.Var.tap" href="#dec:val Hopac.Stream.Var.tap">tap</a><b>:</b> <a href="#def:type Hopac.Stream.Var">Var</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns the generated stream, including the current value of the variable, from the point in time when <code><a href="#def:val Hopac.Stream.Var.tap">tap</a></code> is called.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.nil" href="#dec:val Hopac.Stream.nil">nil</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> An empty or closed choice stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.cons" href="#dec:val Hopac.Stream.cons">cons</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.cons">cons</a>&nbsp;x&nbsp;xs</code> constructs a choice stream whose first value is <code>x</code> and the rest of the stream is like <code>xs</code>.</p><p> Note that <code><a href="#def:val Hopac.Stream.cons">cons</a></code> and <code><a href="#def:val Hopac.Stream.nil">nil</a></code> directly correspond to the ordinary list constructors <code><b>::</b></code> and <code>[]</code> and, aside from the obvious notational differences, you can construct choice streams just like you would create ordinary lists.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.delay" href="#dec:val Hopac.Stream.delay">delay</a><b>:</b> (unit <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.delay">delay</a></code> creates a stream that is constructed lazily.  Use <code><a href="#def:val Hopac.Stream.delay">delay</a></code> to avoid unbounded eager recursion.</p><p> Note that with <code><a href="#def:val Hopac.Stream.delay">delay</a></code>, <code><a href="#def:val Hopac.Stream.cons">cons</a></code> and <code><a href="#def:val Hopac.Stream.nil">nil</a></code>, you can express arbitrary lazy streams.  For example,</p><pre><b>let</b> fibs<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>BigInteger<b>&gt;</b> <b>=</b>
  <b>let</b> <b>rec</b> lp fib0 fib1 <b>=</b> <a href="#def:val Hopac.Stream.cons">cons</a> fib0 <b>&lt;&lt;</b> <a href="#def:val Hopac.Stream.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b> lp fib1 (fib0<b>+</b>fib1)
  lp 0I 1I
</pre><p> is the stream of all fibonacci numbers.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.never" href="#dec:val Hopac.Stream.never">never</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> A choice stream that never produces any values and never closes.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.error" href="#dec:val Hopac.Stream.error">error</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Constructs a choice stream that is closed with an error.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.one" href="#dec:val Hopac.Stream.one">one</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.one">one</a>&nbsp;x</code> is equivalent to <code><a href="#def:val Hopac.Stream.cons">cons</a>&nbsp;x&nbsp;<a href="#def:val Hopac.Stream.nil">nil</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.ofSeq" href="#dec:val Hopac.Stream.ofSeq">ofSeq</a><b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Converts the given sequence to a lazy stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.indefinitely" href="#dec:val Hopac.Stream.indefinitely">indefinitely</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Generates a stream by repeating the given job indefinitely.  For example, given a channel, <code>xCh</code>, a stream can be created, <code><a href="#def:val Hopac.Stream.indefinitely">indefinitely</a>&nbsp;xCh</code>, through which all the values given on the channel can be observed.  See also: <code><a href="#def:val Hopac.Stream.values">values</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.once" href="#dec:val Hopac.Stream.once">once</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.once">once</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:val Hopac.Stream.indefinitely">indefinitely</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Stream.take">take</a>&nbsp;1</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.unfoldJob" href="#dec:val Hopac.Stream.unfoldJob">unfoldJob</a><b>:</b> (<i>'s</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>option<b>&lt;</b><i>'x</i> <b>*</b> <i>'s</i><b>&gt;&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.unfoldFun" href="#dec:val Hopac.Stream.unfoldFun">unfoldFun</a><b>:</b> (<i>'s</i> <b>-&gt;</b> option<b>&lt;</b><i>'x</i> <b>*</b> <i>'s</i><b>&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.iterateJob" href="#dec:val Hopac.Stream.iterateJob">iterateJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.iterateFun" href="#dec:val Hopac.Stream.iterateFun">iterateFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.repeat" href="#dec:val Hopac.Stream.repeat">repeat</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an infinite stream of the given value.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.cycle" href="#dec:val Hopac.Stream.cycle">cycle</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an infinite repetition of the given stream.  For infinite streams <code><a href="#def:val Hopac.Stream.cycle">cycle</a></code> is the identity function.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.subscribeOnFirst" href="#dec:val Hopac.Stream.subscribeOnFirst">subscribeOnFirst</a><b>:</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a stream that subscribes to the observable when the first element of the stream is requested.  Conversely, if no elements are requested from the returned stream, no subscribe action is performed.  There is no way to explicitly unsubscribe.  To limit the subscription, you need to compose the observable in such a way that it is closed at the point when it needs to be unsubscribed.  See also: <code><a href="#def:val Hopac.Stream.subscribeDuring">subscribeDuring</a></code>.</p><p> Note that to subscribe immediately, you can start the evaluation of the returned stream.  You can write, for example,</p><pre>xObs
<b>|&gt;</b> <a href="#def:val Hopac.Stream.subscribeOnFirst">subscribeOnFirst</a>
<b>|&gt;!</b> startIgnore
<b>|&gt;</b> <b>...</b>
</pre><p> where <code><b>|&gt;!</b></code> is the function</p><pre><b>let</b> (<b>|&gt;!</b>) x f <b>=</b> f x ; x
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.subscribeDuring" href="#dec:val Hopac.Stream.subscribeDuring">subscribeDuring</a><b>:</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a stream, using the given function, that subscribes to the observable when the first element of the stream is requested and unsubscribes from the observable when the returned stream closes.  See also: <code><a href="#def:val Hopac.Stream.subscribeOnFirst">subscribeOnFirst</a></code>.</p><p> For example,</p><pre>xObs
<b>|&gt;</b> <a href="#def:val Hopac.Stream.subscribeDuring">subscribeDuring</a> (<b>fun</b> xs <b>-&gt;</b>
   xs
   <b>|&gt;</b> <a href="#def:val Hopac.Stream.take">take</a> 1)
<b>|&gt;</b> <b>...</b>
</pre><p> creates a stream that subscribes to the observable, takes (and produces) at most one element from the observable, and then unsubscribes from the observable and closes.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.subscribingTo" href="#dec:val Hopac.Stream.subscribingTo">subscribingTo</a><b>:</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.toObservable" href="#dec:val Hopac.Stream.toObservable">toObservable</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> IObservable<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns observable that eagerly consumes the stream</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.chooseJob" href="#dec:val Hopac.Stream.chooseJob">chooseJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>option<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces results whenever the given stream produces an element and the given job returns <code>Some</code> result from that element.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.chooseFun" href="#dec:val Hopac.Stream.chooseFun">chooseFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> option<b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces results whenever the given stream produces an element and the given function returns <code>Some</code> result from that element.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.choose" href="#dec:val Hopac.Stream.choose">choose</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>option<b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xs&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Stream.choose">choose</a></code> is equivalent to <code>xs&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Stream.chooseFun">chooseFun</a>&nbsp;id</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.filterJob" href="#dec:val Hopac.Stream.filterJob">filterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>bool<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.filterFun" href="#dec:val Hopac.Stream.filterFun">filterFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.mapJob" href="#dec:val Hopac.Stream.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces elements passed through the given job whenever the given streams produces elements.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Stream.mapJob">mapJob</a> x2yJ xs <b>=</b>
  memo (xs <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>function</b> Nil <b>-&gt;</b> <a href="#def:val Hopac.Stream.nil">nil</a>
                      <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> (x, xs) <b>-&gt;</b>
                        x2yJ x <a href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a> <b>fun</b> y <b>-&gt;</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> (y, <a href="#def:val Hopac.Stream.mapJob">mapJob</a> x2yJ xs))
</pre><p> Above, <code>memo</code> is <code><b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:module Hopac.Promise">Promise</a><b>.</b><a href="#def:module Hopac.Promise.Now">Now</a><b>.</b><a href="#def:val Hopac.Promise.Now.delay">delay</a>&nbsp;x&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.mapFun" href="#dec:val Hopac.Stream.mapFun">mapFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces elements passed through the given function whenever the given streams produces elements.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.groupByJob" href="#dec:val Hopac.Stream.groupByJob">groupByJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'k</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'k</i> <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.groupByFun" href="#dec:val Hopac.Stream.groupByFun">groupByFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'k</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'k</i> <b>*</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.zip" href="#dec:val Hopac.Stream.zip">zip</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream of pairs of elements from the given pair of streams.  No elements from either stream are skipped and each element is used only once.  See also: <code><a href="#def:val Hopac.Stream.combineLatest">combineLatest</a></code>.</p><p> For example,</p><pre><a href="#def:val Hopac.Stream.zip">zip</a> xs (<a href="#def:val Hopac.Stream.tail">tail</a> xs)
</pre><p> is a stream of consecutive pairs from the stream <code>xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.scanJob" href="#dec:val Hopac.Stream.scanJob">scanJob</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.scanFun" href="#dec:val Hopac.Stream.scanFun">scanFun</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.scanFromJob" href="#dec:val Hopac.Stream.scanFromJob">scanFromJob</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.scanFromJob">scanFromJob</a>&nbsp;s&nbsp;sx2sJ&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Stream.scanJob">scanJob</a>&nbsp;sx2sJ&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.scanFromFun" href="#dec:val Hopac.Stream.scanFromFun">scanFromFun</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.scanFromFun">scanFromFun</a>&nbsp;s&nbsp;sx2sJ&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Stream.scanFun">scanFun</a>&nbsp;sx2sJ&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.distinctByJob" href="#dec:val Hopac.Stream.distinctByJob">distinctByJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'k</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.distinctByFun" href="#dec:val Hopac.Stream.distinctByFun">distinctByFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'k</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.distinctUntilChangedWithJob" href="#dec:val Hopac.Stream.distinctUntilChangedWithJob">distinctUntilChangedWithJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>bool<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.distinctUntilChangedWithFun" href="#dec:val Hopac.Stream.distinctUntilChangedWithFun">distinctUntilChangedWithFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.distinctUntilChangedByJob" href="#dec:val Hopac.Stream.distinctUntilChangedByJob">distinctUntilChangedByJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'k</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.distinctUntilChangedByFun" href="#dec:val Hopac.Stream.distinctUntilChangedByFun">distinctUntilChangedByFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'k</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>when</b> <i>'k</i><b>:</b> equality
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.amb" href="#dec:val Hopac.Stream.amb">amb</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Of the two given streams, returns the stream that first produces an element.  See also: <code><a href="#def:val Hopac.Stream.ambMap">ambMap</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.merge" href="#dec:val Hopac.Stream.merge">merge</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces elements from both of the given streams so that elements from the streams are interleaved non-deterministically in the returned stream.  See also: <code><a href="#def:val Hopac.Stream.mergeMap">mergeMap</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> mergeSwap ls rs <b>=</b>
  ls <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>function</b> Nil <b>-&gt;</b> rs
                <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> (l, ls) <b>-&gt;</b> <a href="#def:val Hopac.Stream.cons">cons</a> l (<a href="#def:val Hopac.Stream.merge">merge</a> rs ls)
and <a href="#def:val Hopac.Stream.merge">merge</a> ls rs <b>=</b> mergeSwap ls rs <a href="#def:val Hopac.Promise.Infixes.&lt;|&gt;*">&lt;|&gt;*</a> mergeSwap rs ls
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.append" href="#dec:val Hopac.Stream.append">append</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Concatenates the given two streams.  In other words, returns a stream that first produces all the elements from first stream and then all the elements from the second stream.  If the first stream is infinite, no elements are produced from the second stream.  See also: <code><a href="#def:val Hopac.Stream.appendMap">appendMap</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.switch" href="#dec:val Hopac.Stream.switch">switch</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces elements from the first stream as long as the second stream produces no elements.  As soon as the second stream produces an element, the returned stream only produces elements from the second stream.  See also: <code><a href="#def:val Hopac.Stream.switchMap">switchMap</a></code>.</p><pre> first<b>:</b> a b    c   d
second<b>:</b>      1  2 3  4 <b>...</b>
output<b>:</b> a b  1  2 3  4 <b>...</b>
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.joinWith" href="#dec:val Hopac.Stream.joinWith">joinWith</a><b>:</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>#<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Joins all the streams in the given stream of streams together with the given binary join combinator.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.mapJoin" href="#dec:val Hopac.Stream.mapJoin">mapJoin</a><b>:</b> (<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'z</i><b>&gt;</b> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'z</i><b>&gt;</b>) <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'z</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.mapJoin">mapJoin</a>&nbsp;j&nbsp;f&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Stream.joinWith">joinWith</a>&nbsp;j&nbsp;(<a href="#def:val Hopac.Stream.mapFun">mapFun</a>&nbsp;f&nbsp;xs)</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.ambMap" href="#dec:val Hopac.Stream.ambMap">ambMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Maps and joins all the streams together with <code><a href="#def:val Hopac.Stream.amb">amb</a></code>.  This corresponds to the idea of starting several alternative streams in parallel and then only using the one that produces the first result.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.mergeMap" href="#dec:val Hopac.Stream.mergeMap">mergeMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Maps and joins all the streams together with <code><a href="#def:val Hopac.Stream.merge">merge</a></code>.  This corresponds to interleaving results based on all sources of information.  While this is a theoretically important combinator, <code><a href="#def:val Hopac.Stream.mergeMap">mergeMap</a></code> is probably not the most useful binding form on choice streams.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.appendMap" href="#dec:val Hopac.Stream.appendMap">appendMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Maps and joins all the streams together with <code><a href="#def:val Hopac.Stream.append">append</a></code>.  This is roughly the same function as <code>Seq<b>.</b>collect</code>, but is probably less frequently used with choice streams.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.switchMap" href="#dec:val Hopac.Stream.switchMap">switchMap</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Maps and joins all the streams together with <code><a href="#def:val Hopac.Stream.switch">switch</a></code>.  This is perhaps the most useful binding form with choice streams as this correspond to the idea of producing results based only on the latest source of information.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.skip" href="#dec:val Hopac.Stream.skip">skip</a><b>:</b> int64 <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.skip">skip</a>&nbsp;n&nbsp;xs</code> returns a stream without the first <code>n</code> elements of the given stream.  If the given stream is shorter than <code>n</code>, then the returned stream will be empty.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.take" href="#dec:val Hopac.Stream.take">take</a><b>:</b> int64 <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.take">take</a>&nbsp;n</code> returns a stream that has the first <code>n</code> elements of the given stream.  If the given stream is shorter than <code>n</code>, then <code><a href="#def:val Hopac.Stream.take">take</a>&nbsp;n</code> is the identity function.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.skipUntil" href="#dec:val Hopac.Stream.skipUntil">skipUntil</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.takeUntil" href="#dec:val Hopac.Stream.takeUntil">takeUntil</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.switchOn" href="#dec:val Hopac.Stream.switchOn">switchOn</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.catch" href="#dec:val Hopac.Stream.catch">catch</a><b>:</b> (exn <b>-&gt;</b> #<a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces the same sequence of elements as the given stream.  If the given stream fails, a new stream is constructed by calling the given function and that stream becomes the remainder of the stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.onCloseJob" href="#dec:val Hopac.Stream.onCloseJob">onCloseJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that is just like the given stream except that just before the returned stream is closed, due to the given stream being closed, whether with an error or without, the given job is executed.  In case the job raises an exception, that exception closes the returned stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.onCloseFun" href="#dec:val Hopac.Stream.onCloseFun">onCloseFun</a><b>:</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xs&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Stream.onCloseFun">onCloseFun</a>&nbsp;u2u</code> is equivalent to <code>xs&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Stream.onCloseJob">onCloseJob</a>&nbsp;(<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.thunk">thunk</a>&nbsp;u2u)</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.sample" href="#dec:val Hopac.Stream.sample">sample</a><b>:</b> ticks<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> elems<b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.sample">sample</a>&nbsp;ticks&nbsp;elems</code> returns a stream that produces each <code>elem</code> that is followed by a <code>tick</code>.  Excess elements from both streams are skipped.  In other words, <code>elem</code> followed by <code>elem</code> and <code>tick</code> followed by <code>tick</code> is skipped.</p><pre> elems<b>:</b> 1  2  3        4 5 6  7
 ticks<b>:</b>     x    x    x    x    x
output<b>:</b>     2    3         6    7
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.debounce" href="#dec:val Hopac.Stream.debounce">debounce</a><b>:</b> timeout<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces elements from the given stream so that an element is produced after the given timeout unless a new element is produced by the given stream in which case the timeout is restarted.  Note that if the given stream produces elements more frequently than the timeout, the returned stream never produces any elements.  See also: <code><a href="#def:val Hopac.Stream.throttle">throttle</a></code>.</p><pre>  input<b>:</b> 1        2 3  4     5 6 7 8 9 <b>...</b>
timeout<b>:</b> <b>+---</b>x    <b>+-+--+---</b>x <b>+-+-+-+-+-...</b>
 output<b>:</b>     1             4
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.throttle" href="#dec:val Hopac.Stream.throttle">throttle</a><b>:</b> timeout<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces elements from the given stream so that after an element is produced by the given stream, a timeout is started and the latest element produced by the stream is produced when the timeout expires.  See also: <code><a href="#def:val Hopac.Stream.debounce">debounce</a></code>.</p><pre>  input<b>:</b> 1        2 3   4
timeout<b>:</b> <b>+---</b>x    <b>+---</b>x <b>+---</b>x
 output<b>:</b>     1        3     4
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.combineLatest" href="#dec:val Hopac.Stream.combineLatest">combineLatest</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces a new pair of elements whenever either one of the given pair of streams produces an element.  If one of the streams produces multiple elements before any elements are produced by the other stream, then those elements are skipped.  See also: <code><a href="#def:val Hopac.Stream.zip">zip</a></code>.</p><pre> xs<b>:</b> 1 2                  3     4
 ys<b>:</b>     a     b     c
xys<b>:</b>   (2,a) (2,b) (2,c)(3,c) (4,c)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.shift" href="#dec:val Hopac.Stream.shift">shift</a><b>:</b> timeout<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces the same sequence of elements as the given stream, but shifted in time by the given timeout.</p><pre>  input<b>:</b> 1        2 3   4        5
timeout<b>:</b> <b>+---</b>x    <b>+---</b>x <b>+---</b>x
                    <b>+---</b>x        <b>+---</b>x
 output<b>:</b>     1        2 3   4        5
</pre><p> The <code><a href="#def:val Hopac.Stream.shift">shift</a></code> operation pulls the <code>input</code> while the stream returned by <code><a href="#def:val Hopac.Stream.shift">shift</a></code> is being pulled.  If the stream produced by <code><a href="#def:val Hopac.Stream.shift">shift</a></code> is not pulled, <code><a href="#def:val Hopac.Stream.shift">shift</a></code> will stop pulling the <code>input</code>.</p><p> Note that this operation has a fairly complex implementation.  Unless you absolutely want this behavior, you might prefer a combinator such as <code><a href="#def:val Hopac.Stream.delayEach">delayEach</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.delayEach" href="#dec:val Hopac.Stream.delayEach">delayEach</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces the same elements as the given stream, but delays each pulled element using the given job.  If the given job fails, the returned stream also fails.  See also: <code><a href="#def:val Hopac.Stream.shift">shift</a></code>.</p><pre>  input<b>:</b> 1        2 3   4        5
timeout<b>:</b> <b>+---</b>x    <b>+---</b>x<b>---</b>x<b>---</b>x  <b>+---</b>x
 output<b>:</b>     1        2   3   4      5
</pre><p> In the above, the <code>input</code> is considered to be independent of the pull operations performed by <code><a href="#def:val Hopac.Stream.delayEach">delayEach</a></code>.  For streams that produce output infrequently in relation to the timeout, <code><a href="#def:val Hopac.Stream.delayEach">delayEach</a></code> behaves similarly to <code><a href="#def:val Hopac.Stream.shift">shift</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.afterEach" href="#dec:val Hopac.Stream.afterEach">afterEach</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that produces the same elements as the given stream, but after each element, the given job is used as a delay before a request is made to the given stream for the next element.  If the given job fails, the returned stream also fails.</p><p> Suppose that an application needs to poll for some information, e.g. by making a http request, using a job named <code>poll</code>.  Using <code><a href="#def:val Hopac.Stream.indefinitely">indefinitely</a></code> and <code><a href="#def:val Hopac.Stream.afterEach">afterEach</a></code> we can specify a stream for polling:</p><pre><a href="#def:val Hopac.Stream.indefinitely">indefinitely</a> poll
<b>|&gt;</b> <a href="#def:val Hopac.Stream.afterEach">afterEach</a> (timeOutMillis 10000)
</pre><p> The above stream ensures that polls are at least 10 seconds apart.  Also when polls are requested less frequently, there is no delay before a poll.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.beforeEach" href="#dec:val Hopac.Stream.beforeEach">beforeEach</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream that runs the given job each time a value is requested before requesting the next value from the given stream.  If the given job fails, the returned stream also fails.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Stream.beforeEach">beforeEach</a> yJ xs <b>=</b>
  (yJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a> xs) <a href="#def:val Hopac.Promise.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> <b>function</b> Nil <b>-&gt;</b> <a href="#def:val Hopac.Stream.nil">nil</a>
                          <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> (x, xs) <b>-&gt;</b> <a href="#def:val Hopac.Stream.cons">cons</a> x (<a href="#def:val Hopac.Stream.beforeEach">beforeEach</a> yJ xs)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.atDateTimeOffsets" href="#dec:val Hopac.Stream.atDateTimeOffsets">atDateTimeOffsets</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>DateTimeOffset<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>DateTimeOffset<b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.atDateTimeOffset" href="#dec:val Hopac.Stream.atDateTimeOffset">atDateTimeOffset</a><b>:</b> DateTimeOffset <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>DateTimeOffset<b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.afterTimeSpan" href="#dec:val Hopac.Stream.afterTimeSpan">afterTimeSpan</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.toSeq" href="#dec:val Hopac.Stream.toSeq">toSeq</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.values" href="#dec:val Hopac.Stream.values">values</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Returns a job that creates an alternative through which all the values of the stream generated after the point at which the alternative has been created can be read.  See also: <code><a href="#def:val Hopac.Stream.indefinitely">indefinitely</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.foldJob" href="#dec:val Hopac.Stream.foldJob">foldJob</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.foldFun" href="#dec:val Hopac.Stream.foldFun">foldFun</a><b>:</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <i>'s</i> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> Preliminary and subject to change.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.foldFromJob" href="#dec:val Hopac.Stream.foldFromJob">foldFromJob</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.foldFromJob">foldFromJob</a>&nbsp;s&nbsp;sx2sJ&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Stream.foldJob">foldJob</a>&nbsp;sx2sJ&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.foldFromFun" href="#dec:val Hopac.Stream.foldFromFun">foldFromFun</a><b>:</b> <i>'s</i> <b>-&gt;</b> (<i>'s</i> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <i>'s</i>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'s</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Stream.foldFromFun">foldFromFun</a>&nbsp;s&nbsp;sx2s&nbsp;xs</code> is equivalent to <code><a href="#def:val Hopac.Stream.foldFun">foldFun</a>&nbsp;sx2s&nbsp;s&nbsp;xs</code> and is often syntactically more convenient to use.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.iterJob" href="#dec:val Hopac.Stream.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> #<a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that sequentially iterates the given job constructor over the given stream.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Stream.iterJob">iterJob</a> x2uJ xs <b>=</b>
  xs <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a> <b>function</b> Nil <b>-&gt;</b> Job<b>.</b>unit ()
                <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> (x, xs) <b>-&gt;</b> x2uJ x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a> <a href="#def:val Hopac.Stream.iterJob">iterJob</a> x2uJ xs
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.iterFun" href="#dec:val Hopac.Stream.iterFun">iterFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that sequentially iterates the given function over the given stream.  See also: <code><a href="#def:val Hopac.Stream.iterJob">iterJob</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.count" href="#dec:val Hopac.Stream.count">count</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>int64<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that computes the length of the given stream.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.head" href="#dec:val Hopac.Stream.head">head</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream containing only the first element of the given stream. If the given stream is closed, the result stream will also be closed. Note that <code><a href="#def:val Hopac.Stream.append">append</a>&nbsp;(<a href="#def:val Hopac.Stream.head">head</a>&nbsp;xs)&nbsp;(<a href="#def:val Hopac.Stream.tail">tail</a>&nbsp;xs)</code> is equivalent to <code>xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.tail" href="#dec:val Hopac.Stream.tail">tail</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream just like the given stream except without the first element.  If the given stream is closed, the result stream will also be closed.  Note that <code><a href="#def:val Hopac.Stream.append">append</a>&nbsp;(<a href="#def:val Hopac.Stream.head">head</a>&nbsp;xs)&nbsp;(<a href="#def:val Hopac.Stream.tail">tail</a>&nbsp;xs)</code> is equivalent to <code>xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.tails" href="#dec:val Hopac.Stream.tails">tails</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Returns a stream of all final segments of the given stream from longest to shortest.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Stream.tails">tails</a> xs <b>=</b>
  <a href="#def:val Hopac.Stream.cons">cons</a> xs (xs <a href="#def:val Hopac.Promise.Infixes.&gt;&gt;=*">&gt;&gt;=*</a> <b>function</b> Nil <b>-&gt;</b> <a href="#def:val Hopac.Stream.nil">nil</a>
                          <b>|</b> <a href="#def:type Hopac.Stream.Cons">Cons</a> (_, xs) <b>-&gt;</b> <a href="#def:val Hopac.Stream.tails">tails</a> xs)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Stream.last" href="#dec:val Hopac.Stream.last">last</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream containing the last element of the given stream.  If the given stream is closed, a closed stream is returned.  Note that <code><a href="#def:val Hopac.Stream.append">append</a>&nbsp;(<a href="#def:val Hopac.Stream.init">init</a>&nbsp;xs)&nbsp;(<a href="#def:val Hopac.Stream.last">last</a>&nbsp;xs)</code> is equivalent to <code>xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.init" href="#dec:val Hopac.Stream.init">init</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a stream with all the elements of the given stream except the last element.  If the stream is closed, a closed stream is returned.  Note that <code><a href="#def:val Hopac.Stream.append">append</a>&nbsp;(<a href="#def:val Hopac.Stream.init">init</a>&nbsp;xs)&nbsp;(<a href="#def:val Hopac.Stream.last">last</a>&nbsp;xs)</code> is equivalent to <code>xs</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.inits" href="#dec:val Hopac.Stream.inits">inits</a><b>:</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Returns a stream of all initial segments of the given stream from shortest to longest.</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Hopac.Stream.Builder" href="#dec:type Hopac.Stream.Builder">Builder</a> <b>=</b>
</pre>
<div class="nested"><p> An experimental generic builder for streams.  The abstract <code>Join</code> operation needs to be implemented in a derived class.  The <code>Join</code> operation is then used to implement <code>Bind</code>, <code>Combine</code>, <code>For</code> and <code>While</code> to get a builder with consistent semantics.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.ambed" href="#dec:val Hopac.Stream.ambed">ambed</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
</pre>
<div class="nested"><p> This builder joins substreams with <code><a href="#def:val Hopac.Stream.amb">amb</a></code> to produce a stream with the first results.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.appended" href="#dec:val Hopac.Stream.appended">appended</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
</pre>
<div class="nested"><p> This builder joins substreams with <code><a href="#def:val Hopac.Stream.append">append</a></code> to produce a stream with all results in sequential order.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.merged" href="#dec:val Hopac.Stream.merged">merged</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
</pre>
<div class="nested"><p> This builder joins substreams with <code><a href="#def:val Hopac.Stream.merge">merge</a></code> to produce a stream with all results in completion order.</div>
<pre><b>val</b> <a id="def:val Hopac.Stream.switched" href="#dec:val Hopac.Stream.switched">switched</a><b>:</b> <a href="#def:type Hopac.Stream.Builder">Builder</a>
</pre>
<div class="nested"><p> This builder joins substreams with <code><a href="#def:val Hopac.Stream.switch">switch</a></code> to produce a stream with the latest results.</div>
</div>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="def:module Hopac.TopLevel" href="#dec:module Hopac.TopLevel">TopLevel</a> <b>=</b>
</pre>
<div class="nested"><p> Convenience bindings for programming with Hopac.<pre><b>type</b> <a id="def:type Hopac.TopLevel.Stream" href="#dec:type Hopac.TopLevel.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <a href="#def:module Hopac.Stream">Stream</a><b>.</b><a href="#def:type Hopac.Stream.Stream">Stream</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a non-deterministic stream of values called a choice stream.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.job" href="#dec:val Hopac.TopLevel.job">job</a><b>:</b> <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
</pre>
<div class="nested"><p> Default expression builder for jobs.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.run" href="#dec:val Hopac.TopLevel.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler and then blocks the current thread waiting for the job to either return successfully or fail.</p><p> WARNING: Use of <code><a href="#def:val Hopac.TopLevel.run">run</a></code> should be considered carefully, because calling <code><a href="#def:val Hopac.TopLevel.run">run</a></code> from an arbitrary thread can cause deadlock.</p><p> <code><a href="#def:val Hopac.TopLevel.run">run</a></code> is mainly provided for conveniently running Hopac code from F# Interactive and can also be used as an entry point to the Hopac runtime in console applications.  In Windows applications, for example, <code><a href="#def:val Hopac.TopLevel.run">run</a></code> should not be called from the GUI thread.</p><p> A call of <code><a href="#def:val Hopac.TopLevel.run">run</a>&nbsp;xJ</code> is safe when the call is not made from within a Hopac worker thread and the job <code>xJ</code> does not perform operations that might block or that might directly, or indirectly, need to communicate with the thread from which <code><a href="#def:val Hopac.TopLevel.run">run</a></code> is being called.</p><p> Note that using this function from within a job workflow should never be needed, because within a workflow the result of a job can be obtained by binding.</p><p> This is the same function as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.run">run</a></code>.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.start" href="#dec:val Hopac.TopLevel.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler, but does not wait for the job to finish.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> instead.</p><p> This is the same function as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.startIgnore" href="#dec:val Hopac.TopLevel.startIgnore">startIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.TopLevel.startIgnore">startIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.TopLevel.start">start</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.queue" href="#dec:val Hopac.TopLevel.queue">queue</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Queues the given job for execution on the global scheduler.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.queue">queue</a></code> instead.</p><p> This is the same function as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.queueIgnore" href="#dec:val Hopac.TopLevel.queueIgnore">queueIgnore</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.TopLevel.queueIgnore">queueIgnore</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.Ignore">Ignore</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.TopLevel.queue">queue</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.server" href="#dec:val Hopac.TopLevel.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Like <code><a href="#def:val Hopac.TopLevel.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.server">server</a></code> instead.</p><p> This is the same function as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.server">server</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.asAlt" href="#dec:val Hopac.TopLevel.asAlt">asAlt</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Use object as alternative.  This function is a NOP and is provided as a kind of syntactic alternative to using a type ascription or an <code><b>upcast</b></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.asJob" href="#dec:val Hopac.TopLevel.asJob">asJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Use object as job.  This function is a NOP and is provided as a kind of syntactic alternative to using a type ascription or an <code><b>upcast</b></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.ch" href="#dec:val Hopac.TopLevel.ch">ch</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new channel.  This is the same function as <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Now">Now</a><b>.</b><a href="#def:val Hopac.Ch.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.mb" href="#dec:val Hopac.TopLevel.mb">mb</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new mailbox.  This is the same function as <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:module Hopac.Mailbox.Now">Now</a><b>.</b><a href="#def:val Hopac.Mailbox.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.ivar" href="#dec:val Hopac.TopLevel.ivar">ivar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable.  This is the same function as <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:module Hopac.IVar.Now">Now</a><b>.</b><a href="#def:val Hopac.IVar.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.ivarFull" href="#dec:val Hopac.TopLevel.ivarFull">ivarFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable with the given value.  This is the same function as <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:module Hopac.IVar.Now">Now</a><b>.</b><a href="#def:val Hopac.IVar.Now.createFull">createFull</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.mvar" href="#dec:val Hopac.TopLevel.mvar">mvar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a serialized variable that is initially empty.  This is the same function as <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:module Hopac.MVar.Now">Now</a><b>.</b><a href="#def:val Hopac.MVar.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.mvarFull" href="#dec:val Hopac.TopLevel.mvarFull">mvarFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new serialized variable that initially contains the given value. This is the same function as <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:module Hopac.MVar.Now">Now</a><b>.</b><a href="#def:val Hopac.MVar.Now.createFull">createFull</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.timeOut" href="#dec:val Hopac.TopLevel.timeOut">timeOut</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a timeout for the specified time span.  This is the same function as <code><a href="#def:module Hopac.Timer">Timer</a><b>.</b><a href="#def:module Hopac.Timer.Global">Global</a><b>.</b><a href="#def:val Hopac.Timer.Global.timeOut">timeOut</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.timeOutMillis" href="#dec:val Hopac.TopLevel.timeOutMillis">timeOutMillis</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a timeout for the specified number of milliseconds.  This is the same function as <code><a href="#def:module Hopac.Timer">Timer</a><b>.</b><a href="#def:module Hopac.Timer.Global">Global</a><b>.</b><a href="#def:val Hopac.Timer.Global.timeOutMillis">timeOutMillis</a></code>.</div>
</div>
</div>
</td></tr></table></body>
</html>
