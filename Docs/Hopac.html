<!DOCTYPE html>
<html>
<head>
<title>Hopac Library Reference</title>
<style>
pre {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 5px;
line-height: 160%;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
code {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 2px;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
div.nested {
padding-left: 1.5em;
}
a {
text-decoration: none;
font-weight: bold;
}
</style>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Hopac Library Reference</h1>
<p>This document provides a reference manual for the Hopac library and is generated from the library source code.</p>
<h2>Synopsis</h2>
<pre><b>namespace</b> <a id="dec:namespace Hopac" href="#def:namespace Hopac">Hopac</a></pre>
<pre><b>type</b> <a id="dec:type Hopac.Void" href="#def:type Hopac.Void">Void</a>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.JobBuilder" href="#def:type Hopac.JobBuilder">JobBuilder</a> <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
  <b>member</b> Bind<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> For<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> For<b>:</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryFinally<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryWith<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Using<b>:</b> <i>'x</i> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
  <b>member</b> While<b>:</b> (unit <b>-&gt;</b> bool) <b>*</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="dec:module Hopac.TopLevel" href="#def:module Hopac.TopLevel">TopLevel</a> <b>=</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.job" href="#def:val Hopac.TopLevel.job">job</a><b>:</b> <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
  <b>val</b> <a id="dec:val Hopac.TopLevel.run" href="#def:val Hopac.TopLevel.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
  <b>val</b> <a id="dec:val Hopac.TopLevel.asAlt" href="#def:val Hopac.TopLevel.asAlt">asAlt</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.asJob" href="#def:val Hopac.TopLevel.asJob">asJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.ch" href="#def:val Hopac.TopLevel.ch">ch</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.mb" href="#def:val Hopac.TopLevel.mb">mb</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.ivar" href="#def:val Hopac.TopLevel.ivar">ivar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.TopLevel.mvar" href="#def:val Hopac.TopLevel.mvar">mvar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Job" href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Job" href="#def:module Hopac.Job">Job</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Job.Global" href="#def:module Hopac.Job.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Job.Global.startWithActions" href="#def:val Hopac.Job.Global.startWithActions">startWithActions</a><b>:</b> (exn <b>-&gt;</b> unit) <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.start" href="#def:val Hopac.Job.Global.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.server" href="#def:val Hopac.Job.Global.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
    <b>val</b> <a id="dec:val Hopac.Job.Global.run" href="#def:val Hopac.Job.Global.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
  <b>val</b> <a id="dec:val Hopac.Job.start" href="#def:val Hopac.Job.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.server" href="#def:val Hopac.Job.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.startWithFinalizer" href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.delay" href="#def:val Hopac.Job.delay">delay</a><b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.delayWith" href="#def:val Hopac.Job.delayWith">delayWith</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.lift" href="#def:val Hopac.Job.lift">lift</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.thunk" href="#def:val Hopac.Job.thunk">thunk</a><b>:</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.unit" href="#def:val Hopac.Job.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.result" href="#def:val Hopac.Job.result">result</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.abort" href="#def:val Hopac.Job.abort">abort</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.raises" href="#def:val Hopac.Job.raises">raises</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Job.Infixes" href="#def:module Hopac.Job.Infixes">Infixes</a> <b>=</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;=" href="#def:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;." href="#def:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes..&gt;&gt;" href="#def:val Hopac.Job.Infixes..&gt;&gt;">.&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.|&gt;&gt;" href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;%" href="#def:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&gt;&gt;!" href="#def:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&lt;&amp;&gt;" href="#def:val Hopac.Job.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Job.Infixes.&lt;*&gt;" href="#def:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryIn" href="#def:val Hopac.Job.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryWith" href="#def:val Hopac.Job.tryWith">tryWith</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryFinallyFun" href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.tryFinallyJob" href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.using" href="#def:val Hopac.Job.using">using</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
  <b>val</b> <a id="dec:val Hopac.Job.catch" href="#def:val Hopac.Job.catch">catch</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Choice<b>&lt;</b><i>'x</i>, exn<b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forN" href="#def:val Hopac.Job.forN">forN</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forUpTo" href="#def:val Hopac.Job.forUpTo">forUpTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forDownTo" href="#def:val Hopac.Job.forDownTo">forDownTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.whileDo" href="#def:val Hopac.Job.whileDo">whileDo</a><b>:</b> (unit <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.whenDo" href="#def:val Hopac.Job.whenDo">whenDo</a><b>:</b> bool <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.forever" href="#def:val Hopac.Job.forever">forever</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.iterate" href="#def:val Hopac.Job.iterate">iterate</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.foreverServer" href="#def:val Hopac.Job.foreverServer">foreverServer</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.iterateServer" href="#def:val Hopac.Job.iterateServer">iterateServer</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.seqCollect" href="#def:val Hopac.Job.seqCollect">seqCollect</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.seqIgnore" href="#def:val Hopac.Job.seqIgnore">seqIgnore</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.conCollect" href="#def:val Hopac.Job.conCollect">conCollect</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.conIgnore" href="#def:val Hopac.Job.conIgnore">conIgnore</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.fromBeginEnd" href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a><b>:</b> (AsyncCallback <b>*</b> obj <b>-&gt;</b> IAsyncResult)
                 <b>-&gt;</b> (IAsyncResult <b>-&gt;</b> <i>'x</i>)
                 <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Job.scheduler" href="#def:val Hopac.Job.scheduler">scheduler</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Scheduler">Scheduler</a><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Alt" href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Alt" href="#def:module Hopac.Alt">Alt</a> <b>=</b>
  <b>val</b> <a id="dec:val Hopac.Alt.always" href="#def:val Hopac.Alt.always">always</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.unit" href="#def:val Hopac.Alt.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.never" href="#def:val Hopac.Alt.never">never</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.zero" href="#def:val Hopac.Alt.zero">zero</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.guard" href="#def:val Hopac.Alt.guard">guard</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.delay" href="#def:val Hopac.Alt.delay">delay</a><b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.withNack" href="#def:val Hopac.Alt.withNack">withNack</a><b>:</b> (<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.choose" href="#def:val Hopac.Alt.choose">choose</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Alt.Infixes" href="#def:module Hopac.Alt.Infixes">Infixes</a> <b>=</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&lt;|&gt;" href="#def:val Hopac.Alt.Infixes.&lt;|&gt;">&lt;|&gt;</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;=?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;.?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;.?">&gt;&gt;.?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes..&gt;&gt;?" href="#def:val Hopac.Alt.Infixes..&gt;&gt;?">.&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.|&gt;&gt;?" href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;%?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
    <b>val</b> (<a id="dec:val Hopac.Alt.Infixes.&gt;&gt;!?" href="#def:val Hopac.Alt.Infixes.&gt;&gt;!?">&gt;&gt;!?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.tryIn" href="#def:val Hopac.Alt.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.pick" href="#def:val Hopac.Alt.pick">pick</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Alt.select" href="#def:val Hopac.Alt.select">select</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Timer" href="#def:module Hopac.Timer">Timer</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Timer.Global" href="#def:module Hopac.Timer.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Timer.Global.timeOut" href="#def:val Hopac.Timer.Global.timeOut">timeOut</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Timer.Global.sleep" href="#def:val Hopac.Timer.Global.sleep">sleep</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Ch" href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Ch" href="#def:module Hopac.Ch">Ch</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Ch.Now" href="#def:module Hopac.Ch.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Now.create" href="#def:val Hopac.Ch.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Ch.Global" href="#def:module Hopac.Ch.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Global.send" href="#def:val Hopac.Ch.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Ch.create" href="#def:val Hopac.Ch.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Ch.give" href="#def:val Hopac.Ch.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Ch.send" href="#def:val Hopac.Ch.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Ch.take" href="#def:val Hopac.Ch.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Ch.Alt" href="#def:module Hopac.Ch.Alt">Alt</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Alt.give" href="#def:val Hopac.Ch.Alt.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Ch.Alt.take" href="#def:val Hopac.Ch.Alt.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.IVar" href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.IVar" href="#def:module Hopac.IVar">IVar</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.IVar.Now" href="#def:module Hopac.IVar.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.IVar.Now.create" href="#def:val Hopac.IVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.create" href="#def:val Hopac.IVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.fill" href="#def:val Hopac.IVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.fillFailure" href="#def:val Hopac.IVar.fillFailure">fillFailure</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.IVar.read" href="#def:val Hopac.IVar.read">read</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.IVar.Alt" href="#def:module Hopac.IVar.Alt">Alt</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.IVar.Alt.read" href="#def:val Hopac.IVar.Alt.read">read</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.MVar" href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.MVar" href="#def:module Hopac.MVar">MVar</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.MVar.Now" href="#def:module Hopac.MVar.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.MVar.Now.create" href="#def:val Hopac.MVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.MVar.Now.createFull" href="#def:val Hopac.MVar.Now.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.create" href="#def:val Hopac.MVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.createFull" href="#def:val Hopac.MVar.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.fill" href="#def:val Hopac.MVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.take" href="#def:val Hopac.MVar.take">take</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.modifyFun" href="#def:val Hopac.MVar.modifyFun">modifyFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>*</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.MVar.modifyJob" href="#def:val Hopac.MVar.modifyJob">modifyJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.MVar.Alt" href="#def:module Hopac.MVar.Alt">Alt</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.MVar.Alt.take" href="#def:val Hopac.MVar.Alt.take">take</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Mailbox" href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Mailbox" href="#def:module Hopac.Mailbox">Mailbox</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Mailbox.Now" href="#def:module Hopac.Mailbox.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Mailbox.Now.create" href="#def:val Hopac.Mailbox.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Mailbox.Global" href="#def:module Hopac.Mailbox.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Mailbox.Global.send" href="#def:val Hopac.Mailbox.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Mailbox.create" href="#def:val Hopac.Mailbox.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Mailbox.send" href="#def:val Hopac.Mailbox.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Mailbox.take" href="#def:val Hopac.Mailbox.take">take</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Mailbox.Alt" href="#def:module Hopac.Mailbox.Alt">Alt</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Mailbox.Alt.take" href="#def:val Hopac.Mailbox.Alt.take">take</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Promise" href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Promise" href="#def:module Hopac.Promise">Promise</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Promise.Now" href="#def:module Hopac.Promise.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.delay" href="#def:val Hopac.Promise.Now.delay">delay</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.withValue" href="#def:val Hopac.Promise.Now.withValue">withValue</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Now.withFailure" href="#def:val Hopac.Promise.Now.withFailure">withFailure</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Promise.start" href="#def:val Hopac.Promise.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Promise.delay" href="#def:val Hopac.Promise.delay">delay</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Promise.read" href="#def:val Hopac.Promise.read">read</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Promise.Alt" href="#def:module Hopac.Promise.Alt">Alt</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Promise.Alt.read" href="#def:val Hopac.Promise.Alt.read">read</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Lock" href="#def:type Hopac.Lock">Lock</a>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Lock" href="#def:module Hopac.Lock">Lock</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Lock.Now" href="#def:module Hopac.Lock.Now">Now</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Lock.Now.create" href="#def:val Hopac.Lock.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Lock">Lock</a>
  <b>val</b> <a id="dec:val Hopac.Lock.create" href="#def:val Hopac.Lock.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Lock">Lock</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Lock.duringFun" href="#def:val Hopac.Lock.duringFun">duringFun</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Hopac.Lock.duringJob" href="#def:val Hopac.Lock.duringJob">duringJob</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Extensions" href="#def:module Hopac.Extensions">Extensions</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Extensions.Array" href="#def:module Hopac.Extensions.Array">Array</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Array.mapJob" href="#def:val Hopac.Extensions.Array.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>array<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Array.iterJob" href="#def:val Hopac.Extensions.Array.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>module</b> <a id="dec:module Hopac.Extensions.Seq" href="#def:module Hopac.Extensions.Seq">Seq</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.iterJob" href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.mapJob" href="#def:val Hopac.Extensions.Seq.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
    <b>val</b> <a id="dec:val Hopac.Extensions.Seq.foldJob" href="#def:val Hopac.Extensions.Seq.foldJob">foldJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> seq<b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>module</b> <a id="dec:module Hopac.Extensions.Seq.Con" href="#def:module Hopac.Extensions.Seq.Con">Con</a> <b>=</b>
      <b>val</b> <a id="dec:val Hopac.Extensions.Seq.Con.iterJob" href="#def:val Hopac.Extensions.Seq.Con.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
      <b>val</b> <a id="dec:val Hopac.Extensions.Seq.Con.mapJob" href="#def:val Hopac.Extensions.Seq.Con.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
  <b>[&lt;</b>Sealed<b>&gt;]</b> 
  <b>type</b> <a id="dec:type Hopac.Extensions.Task" href="#def:type Hopac.Extensions.Task">Task</a> <b>=</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.awaitJob" href="#def:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> Threading<b>.</b>Tasks<b>.</b>Task<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Extensions.Task.awaitJob" href="#def:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> Threading<b>.</b>Tasks<b>.</b>Task <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Hopac.Scheduler" href="#def:type Hopac.Scheduler">Scheduler</a>
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Scheduler" href="#def:module Hopac.Scheduler">Scheduler</a> <b>=</b>
  <b>module</b> <a id="dec:module Hopac.Scheduler.Global" href="#def:module Hopac.Scheduler.Global">Global</a> <b>=</b>
    <b>val</b> <a id="dec:val Hopac.Scheduler.Global.setTopLevelHandler" href="#def:val Hopac.Scheduler.Global.setTopLevelHandler">setTopLevelHandler</a><b>:</b> option<b>&lt;</b>exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b> <b>-&gt;</b> unit
  <b>type</b> <a id="dec:type Hopac.Scheduler.Create" href="#def:type Hopac.Scheduler.Create">Create</a> <b>=</b>
    {
      <a id="dec:field Hopac.Scheduler.Create.Foreground" href="#def:field Hopac.Scheduler.Create.Foreground">Foreground</a><b>:</b> option<b>&lt;</b>bool<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.IdleHandler" href="#def:field Hopac.Scheduler.Create.IdleHandler">IdleHandler</a><b>:</b> option<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>int<b>&gt;&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.MaxStackSize" href="#def:field Hopac.Scheduler.Create.MaxStackSize">MaxStackSize</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.NumWorkers" href="#def:field Hopac.Scheduler.Create.NumWorkers">NumWorkers</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.Priority" href="#def:field Hopac.Scheduler.Create.Priority">Priority</a><b>:</b> option<b>&lt;</b>Threading<b>.</b>ThreadPriority<b>&gt;</b>
      <a id="dec:field Hopac.Scheduler.Create.TopLevelHandler" href="#def:field Hopac.Scheduler.Create.TopLevelHandler">TopLevelHandler</a><b>:</b> option<b>&lt;</b>exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b>
    }
    <b>static</b> <b>member</b> <a id="dec:static member Hopac.Scheduler.Create.Def" href="#def:static member Hopac.Scheduler.Create.Def">Def</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a>
  <b>val</b> <a id="dec:val Hopac.Scheduler.create" href="#def:val Hopac.Scheduler.create">create</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a> <b>-&gt;</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
  <b>val</b> <a id="dec:val Hopac.Scheduler.startWithActions" href="#def:val Hopac.Scheduler.startWithActions">startWithActions</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
                     <b>-&gt;</b> (exn <b>-&gt;</b> unit)
                     <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit)
                     <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.start" href="#def:val Hopac.Scheduler.start">start</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.server" href="#def:val Hopac.Scheduler.server">server</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.wait" href="#def:val Hopac.Scheduler.wait">wait</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
  <b>val</b> <a id="dec:val Hopac.Scheduler.kill" href="#def:val Hopac.Scheduler.kill">kill</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
</pre>
<pre><b>module</b> <a id="dec:module Hopac.Infixes" href="#def:module Hopac.Infixes">Infixes</a> <b>=</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-?" href="#def:val Hopac.Infixes.&lt;-?">&lt;-?</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;--" href="#def:val Hopac.Infixes.&lt;--">&lt;--</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-+" href="#def:val Hopac.Infixes.&lt;-+">&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-=" href="#def:val Hopac.Infixes.&lt;-=">&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;-=!" href="#def:val Hopac.Infixes.&lt;-=!">&lt;-=!</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;&lt;-=" href="#def:val Hopac.Infixes.&lt;&lt;-=">&lt;&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> (<a id="dec:val Hopac.Infixes.&lt;&lt;-+" href="#def:val Hopac.Infixes.&lt;&lt;-+">&lt;&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<h2>Description</h2>
<pre><b>namespace</b> <a id="def:namespace Hopac" href="#dec:namespace Hopac">Hopac</a>
</pre>
<div class="nested"><p> Hopac is a library for F# with the aim of making it easier to write efficient parallel, asynchronous and concurrent programs.  The design of Hopac draws inspiration from languages such as Concurrent ML and Cilk. Similar to Concurrent ML, Hopac provides message passing primitives and supports the construction of first-class synchronous abstractions.  Parallel jobs (lightweight threads) in Hopac are created using techniques similar to the F# Async framework.  Hopac runs parallel jobs using a work distributing scheduler in a non-preemptive fashion.</p><p> Before you begin using Hopac, make sure that you have configured your F# interactive and your application to use server garbage collection.  By default, .Net uses single-threaded workstation garbage collection, which makes it impossible for parallel programs to scale.</p><p> The documentation of many of the primitives contains a reference implementation.  In most cases, actual implementations are optimized by taking advantage of internal implementation details and may be significantly faster than the reference implementation.  The reference implementations are given for a number of reasons.  First of all, they hopefully help to better understand the semantics of the primitives.  In some cases, the reference implementations also demonstrate how you can interface Hopac with other systems without the need to extend the primitives of Hopac.  The reference implementations can also be seen as examples of how various primitives can be used to implement more complex operations.</p><p> As can quickly be observed, the various primitives and modules of Hopac are named and structured using a number of patterns.</p><p> Many modules contain a module named <code>Global</code>, which contains operations bound to the global scheduler that is implicitly managed by the Hopac library.  The global scheduler is created when an operation, such as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.run">run</a></code>, requires it.  If a program never uses an operation that requires the global scheduler, then no global scheduler will be created. This allows programs to be written that explicitly manage their own local schedulers.</p><p> Modules for various communication primitives contain a module named <code>Now</code>, which contains operations that can be efficiently performed as non-concurrent operations.  For example, there is a concurrent <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.create">create</a></code> operation, which needs to be run to create a new channel and also a <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Now">Now</a><b>.</b><a href="#def:val Hopac.Ch.Now.create">create</a></code> function that directly creates a new channel.  In cases where such efficient non-concurrent functions are provided, you should prefer to use them, because they avoid the overhead of running concurrent operations.  However, in cases where operations really need to perform concurrent operations, such as starting a concurrent server, you should prefer not to encapsulate those operations as ordinary functions, because running individual concurrent operations via some scheduler incurs overheads and it is preferable to construct longer sequences of concurrent operations to run.</p><p> Many modules also contain a module named <code>Alt</code>, which contains primitive selective operations to be used with other selective communication operations.</p><p> For some infix operators there are both <code>Job</code> and <code>Alt</code> level versions.  The <code>Alt</code> level versions end with a question mark <code><b>?</b></code> that indicates the selective nature of the operation.</p><p> Some higher-order operations make sense to use with both non-concurrent user defined functions and with user defined concurrent jobs and in such cases there are often two versions of the higher-order functions, with one having the suffix <code>Fun</code> and the other having the suffix <code>Job</code>.  You should prefer the <code>Job</code> version when you need to perform concurrent operations and otherwise the <code>Fun</code> version.<pre><b>type</b> <a id="def:type Hopac.Void" href="#dec:type Hopac.Void">Void</a>
</pre>
<div class="nested"><p> A type that has no public constructors to indicate that a job or function does not return normally.</div>
<pre><b>type</b> <a id="def:type Hopac.JobBuilder" href="#dec:type Hopac.JobBuilder">JobBuilder</a> <b>=</b>
</pre>
<div class="nested"><p> Expression builder type for jobs.</p><p> The following expression constructs are supported:</p><pre><b>...</b> ; <b>...</b>
<b>do</b> <b>...</b>
<b>do</b><b>!</b> <b>...</b>
<b>for</b> <b>...</b> <b>=</b> <b>...</b> <b>to</b> <b>...</b> <b>do</b> <b>...</b>
<b>for</b> <b>...</b> <b>in</b> <b>...</b> <b>do</b> <b>...</b>
<b>if</b> <b>...</b> <b>then</b> <b>...</b>
<b>if</b> <b>...</b> <b>then</b> <b>...</b> <b>else</b> <b>...</b>
<b>let</b> <b>...</b> <b>=</b> <b>...</b> <b>in</b> <b>...</b>
<b>let</b><b>!</b> <b>...</b> <b>=</b> <b>...</b> <b>in</b> <b>...</b>
<b>match</b> <b>...</b> <b>with</b> <b>...</b>
<b>return</b> <b>...</b>
<b>return</b><b>!</b> <b>...</b>
<b>try</b> <b>...</b> <b>finally</b> <b>...</b>
<b>try</b> <b>...</b> <b>with</b> <b>...</b>
<b>use</b> <b>...</b> <b>in</b> <b>...</b>
<b>use</b><b>!</b> <b>...</b> <b>in</b> <b>...</b>
<b>while</b> <b>...</b> <b>do</b> <b>...</b>
</pre><p> Note that the <code><a href="#def:type Hopac.Job">Job</a></code> module provides more combinators for constructing jobs. For example, the F# workflow notation does not support <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a></code> and <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> is easier to use correctly than <code><b>try</b>&nbsp;<b>...</b>&nbsp;<b>with</b>&nbsp;<b>...</b></code> expressions.  Operators such as <code><a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a></code> and <code><a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a></code> and operations such as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.iterate">iterate</a></code> and <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.forever">forever</a></code> are frequently useful and may improve performance.</div>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="def:module Hopac.TopLevel" href="#dec:module Hopac.TopLevel">TopLevel</a> <b>=</b>
</pre>
<div class="nested"><p> Convenience bindings for programming with Hopac.<pre><b>val</b> <a id="def:val Hopac.TopLevel.job" href="#dec:val Hopac.TopLevel.job">job</a><b>:</b> <a href="#def:type Hopac.JobBuilder">JobBuilder</a>
</pre>
<div class="nested"><p> Default expression builder for jobs.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.run" href="#dec:val Hopac.TopLevel.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler and then waits for the job to either return successfully or fail.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</p><p> Note that using this function in a job workflow is not optimal and should never be needed, because within a workflow the result of a job can be obtained by binding.</p><p> This is the same function as <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.run">run</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.asAlt" href="#dec:val Hopac.TopLevel.asAlt">asAlt</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Use object as alternative.  This function is a NOP and is provided as a kind of syntactic alternative to using a type cast.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.asJob" href="#dec:val Hopac.TopLevel.asJob">asJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Use object as job.  This function is a NOP and is provided as a kind of syntactic alternative to using a type cast.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.ch" href="#dec:val Hopac.TopLevel.ch">ch</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new channel.  This is the same function as <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Now">Now</a><b>.</b><a href="#def:val Hopac.Ch.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.mb" href="#dec:val Hopac.TopLevel.mb">mb</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new mailbox.  This is the same function as <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:module Hopac.Mailbox.Now">Now</a><b>.</b><a href="#def:val Hopac.Mailbox.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.ivar" href="#dec:val Hopac.TopLevel.ivar">ivar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable.  This is the same function as <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:module Hopac.IVar.Now">Now</a><b>.</b><a href="#def:val Hopac.IVar.Now.create">create</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.TopLevel.mvar" href="#dec:val Hopac.TopLevel.mvar">mvar</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a serialized variable that is initially empty.  This is the same function as <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:module Hopac.MVar.Now">Now</a><b>.</b><a href="#def:val Hopac.MVar.Now.create">create</a></code>.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Job" href="#dec:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a lightweight thread of execution.</p><p> Jobs are defined using expression builders like the <code><a href="#def:type Hopac.JobBuilder">JobBuilder</a></code>, accessible via the <code><a href="#def:module Hopac.TopLevel">TopLevel</a><b>.</b><a href="#def:val Hopac.TopLevel.job">job</a></code> binding, or using monadic combinators and can then be executed on some <code><a href="#def:type Hopac.Scheduler">Scheduler</a></code> such as the global scheduler accessible via the <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a></code> module.</p><p> For example, here is a function that creates of a job that computes Fibonacci numbers:</p><pre><b>let</b> <b>rec</b> fib n <b>=</b> <a href="#def:val Hopac.TopLevel.job">job</a> {
  <b>if</b> n <b>&lt;</b> 2L <b>then</b>
    <b>return</b> n
  <b>else</b>
    <b>let</b><b>!</b> (x, y) <b>=</b> fib (n<b>-</b>2L) <a href="#def:val Hopac.Job.Infixes.&lt;*&gt;"><*></a> fib (n<b>-</b>1L)
    <b>return</b> x<b>+</b>y
}
</pre><p> It can be run, for example, by using the global scheduler:</p><pre><b>&gt;</b> run (fib 30L) ;;
<b>val</b> it <b>:</b> int <b>=</b> 832040L
</pre><p> If you ran the above above examples, you just did the equivalent of running roughly your first million parallel jobs using Hopac.</div>
<pre><b>module</b> <a id="def:module Hopac.Job" href="#dec:module Hopac.Job">Job</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on jobs.<pre><b>module</b> <a id="def:module Hopac.Job.Global" href="#dec:module Hopac.Job.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global scheduler.</p><p> Note that in a typical program there should only be a few points (maybe just one) where jobs are started or run outside of job workflows.<pre><b>val</b> <a id="def:val Hopac.Job.Global.startWithActions" href="#dec:val Hopac.Job.Global.startWithActions">startWithActions</a><b>:</b> (exn <b>-&gt;</b> unit) <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler, but does not wait for the job to finish.  Upon the failure or success of the job, one of the given actions is called once.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</p><p> Note that using this function in a job workflow is not optimal and you should instead use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> with the desired exception handling construct (e.g. <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> or <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.catch">catch</a></code>).</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.start" href="#dec:val Hopac.Job.Global.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler, but does not wait for the job to finish.  The result, if any, of the job is ignored.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.server" href="#dec:val Hopac.Job.Global.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Like <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:module Hopac.Job.Global">Global</a><b>.</b><a href="#def:val Hopac.Job.Global.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.server">server</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.Global.run" href="#dec:val Hopac.Job.Global.run">run</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Starts running the given job on the global scheduler and then waits for the job to either return successfully or fail.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</p><p> Note that using this function in a job workflow is not optimal and should never be needed, because within a workflow the result of a job can be obtained by binding.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Job.start" href="#dec:val Hopac.Job.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that schedules the given job to be executed as a separate concurrent job.  The result, if any, of the concurrent job is ignored. Use <code><a href="#def:module Hopac.Promise">Promise</a><b>.</b><a href="#def:val Hopac.Promise.start">start</a></code> if you need to be able to get the result.  Use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.server">server</a></code> if the job never returns normally.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.server" href="#dec:val Hopac.Job.server">server</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Like <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.startWithFinalizer" href="#dec:val Hopac.Job.startWithFinalizer">startWithFinalizer</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a>&nbsp;finalizerJ&nbsp;xJ</code> is like <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a>&nbsp;xJ</code>, but attaches a finalizer to the started job.  The finalizer job is started as a separate job in case the started job does not return succesfully or raise an exception and is garbage collected.  The result, if any, of the concurrent job is ignored, but if the job either returns normally or raises an exception, the finalizer job is not started.</p><p> When a job in Hopac is aborted (see <code><a href="#def:val Hopac.Job.abort">abort</a></code>) or is, for example, blocked waiting for communication on a channel that is no longer reachable, the job can be garbage collected.  Most concurrent jobs should not need a finalizer and can be garbage collected safely in case they are blocked indefinitely or aborted.  However, in some cases it may be useful to be able to detect, for debugging reasons, or handle, for fault tolerance, a case where a job is garbage collected.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.delay" href="#dec:val Hopac.Job.delay">delay</a><b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function to build a job that will then be run.  <code><a href="#def:val Hopac.Job.delay">delay</a>&nbsp;u2xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;()&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;u2xJ</code>.</p><p> Use of <code><a href="#def:val Hopac.Job.delay">delay</a></code> is often essential for making sure that a job constructed with user-defined code properly captures side-effects performed in the user-defined code or that a job is not constructed too eagerly (e.g. traversing an entire data structure to build a very large job object).  However, it is also the case that there is no need to wrap every constructed job with <code><a href="#def:val Hopac.Job.delay">delay</a></code> and avoiding unnecessary <code><a href="#def:val Hopac.Job.delay">delay</a></code> operations can improve performance.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.delayWith" href="#dec:val Hopac.Job.delayWith">delayWith</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function with the given value to build a job that will then be run.  <code><a href="#def:val Hopac.Job.delayWith">delayWith</a>&nbsp;x2yJ&nbsp;x</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;x&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;x2yJ</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.lift" href="#dec:val Hopac.Job.lift">lift</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function with the given value to compute the result of the job.  <code><a href="#def:val Hopac.Job.lift">lift</a>&nbsp;x2y&nbsp;x</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;x&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a>&nbsp;x2y</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.thunk" href="#dec:val Hopac.Job.thunk">thunk</a><b>:</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that invokes the given thunk to compute the result of the job.  <code><a href="#def:val Hopac.Job.thunk">thunk</a>&nbsp;u2x</code> is equivalent to <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;()&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a>&nbsp;u2x</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.unit" href="#dec:val Hopac.Job.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that does nothing and returns <code>()</code>.  <code><a href="#def:val Hopac.Job.unit">unit</a>&nbsp;()</code> is an optimized version of <code><a href="#def:val Hopac.Job.result">result</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.result" href="#dec:val Hopac.Job.result">result</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job with the given result.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.abort" href="#dec:val Hopac.Job.abort">abort</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that immediately terminates the current job.  See also: <code><a href="#def:val Hopac.Job.startWithFinalizer">startWithFinalizer</a></code>.</p><p> Note that when a job aborts, it is considered to be equivalent to having the job block indefinitely.  This means that the job neither returns succesfully nor fails with an exception.  While this may sound like something that you should worry about, it is, in fact, frequently just what you want.  That is, rather than worry about carefully terminating each and every concurrent job, it is preferable to just let them be garbage collected.  Only jobs that explicitly hold onto some important resource need to be carefully managed.</p><p> Note that in order to execute clean-up operations implemented with <code><a href="#def:val Hopac.Job.using">using</a></code> or <code><a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a></code> or <code><a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a></code> the job must either return normally or raise an exception.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.raises" href="#dec:val Hopac.Job.raises">raises</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that has the effect of raising the specified exception. <code><a href="#def:val Hopac.Job.raises">raises</a>&nbsp;e</code> is equivalent to <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delayWith">delayWith</a>&nbsp;raise&nbsp;e</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Job.Infixes" href="#dec:module Hopac.Job.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Infix operators on jobs.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;=" href="#dec:val Hopac.Job.Infixes.&gt;&gt;=">&gt;&gt;=</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that first runs the given job and then passes the result of that job to the given function to build another job which will then be run.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;." href="#dec:val Hopac.Job.Infixes.&gt;&gt;.">&gt;&gt;.</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given two jobs and returns the result of the second job.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;.">>>.</a>&nbsp;yJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;yJ</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes..&gt;&gt;" href="#dec:val Hopac.Job.Infixes..&gt;&gt;">.&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given two jobs and returns the result of the first job.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes..&gt;&gt;">.>></a>&nbsp;yJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;yJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a>&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.|&gt;&gt;" href="#dec:val Hopac.Job.Infixes.|&gt;&gt;">|&gt;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and maps the result of the job with the given function.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a>&nbsp;x2y</code> is an optimized version of <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;(x2y&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>)</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;%" href="#dec:val Hopac.Job.Infixes.&gt;&gt;%">&gt;&gt;%</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and then returns the given value. <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a>&nbsp;y</code> is an optimized version of <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>&nbsp;y</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&gt;&gt;!" href="#dec:val Hopac.Job.Infixes.&gt;&gt;!">&gt;&gt;!</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and then raises the given exception.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;!">>>!</a>&nbsp;e</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;raise&nbsp;e</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&lt;&amp;&gt;" href="#dec:val Hopac.Job.Infixes.&lt;&amp;&gt;">&lt;&amp;&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given two jobs and then returns a pair of their results.  <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&lt;&amp;&gt;"><&></a>&nbsp;yJ</code> is equivalent to <code>xJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;yJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;y&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>&nbsp;(x,&nbsp;y)</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Job.Infixes.&lt;*&gt;" href="#dec:val Hopac.Job.Infixes.&lt;*&gt;">&lt;*&gt;</a>)<b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that either runs the given jobs sequentially, like <code><a href="#def:val Hopac.Job.Infixes.&lt;&amp;&gt;"><&></a></code>, or as two separate parallel jobs and returns a pair of their results.</p><p> Note that when the jobs are run in parallel and both of them raise an exception then the created job raises an <code>AggregateException</code>.</p><p> Note that, because it is not guaranteed that the jobs would always be run as separate parallel jobs, a job such as</p><pre><b>let</b> mayDeadlock <b>=</b> <a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> c <b>=</b> <a href="#def:val Hopac.TopLevel.ch">ch</a> ()
  <a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.give">give</a> c () <a href="#def:val Hopac.Job.Infixes.&lt;*&gt;"><*></a> <a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.take">take</a> c
</pre><p> may deadlock.  If two jobs need to communicate with each other they need to be started as two separate jobs.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryIn" href="#dec:val Hopac.Job.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements the try-in-unless exception handling construct for jobs.  Both of the continuation jobs <code><i>'x</i>&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for success, and <code>exn&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for failure, are invoked from a tail position.</p><p> Note that the workflow notation of F# does not support this operation.  It only supports the <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryWith">tryWith</a></code> operation.  <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> makes it easier to write exception handling code that has the desired tail-call properties.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryWith" href="#dec:val Hopac.Job.tryWith">tryWith</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements the try-with exception handling construct for jobs.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.tryWith">tryWith</a> xJ e2xJ <b>=</b> <a href="#def:val Hopac.Job.tryIn">tryIn</a> xJ <a href="#def:val Hopac.Job.result">result</a> e2xJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryFinallyFun" href="#dec:val Hopac.Job.tryFinallyFun">tryFinallyFun</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements a variation of the try-finally exception handling construct for jobs.  The given action, specified as a function, is executed after the job has been run, whether it fails or completes successfully.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a> xJ u2u <b>=</b> <a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a> xJ (<a href="#def:val Hopac.Job.thunk">thunk</a> u2u)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.tryFinallyJob" href="#dec:val Hopac.Job.tryFinallyJob">tryFinallyJob</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements a variation of the try-finally exception handling construct for jobs.  The given action, specified as a job, is executed after the the job has been run, whether it fails or completes successfully.</p><p> Note that the workflow notation of F# does not support this operation.  It only supports the weaker <code><a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a></code> operation.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.tryFinallyJob">tryFinallyJob</a> xJ uJ <b>=</b>
  <a href="#def:val Hopac.Job.tryIn">tryIn</a> xJ
   <b>&lt;|</b> <b>fun</b> x <b>-&gt;</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a> x
   <b>&lt;|</b> <b>fun</b> e <b>-&gt;</b> uJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;!">>>!</a> e
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.using" href="#dec:val Hopac.Job.using">using</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
</pre>
<div class="nested"><p> Implements the use construct for jobs.  The Dispose method of the given disposable object is called after running the job constructed with the disposable object.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.using">using</a> (x<b>:</b> <i>'x</i> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable) x2yJ <b>=</b>
  <a href="#def:val Hopac.Job.tryFinallyFun">tryFinallyFun</a> (<a href="#def:val Hopac.Job.delayWith">delayWith</a> x2yJ x) (x <b>:&gt;</b> IDisposable)<b>.</b>Dispose
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.catch" href="#dec:val Hopac.Job.catch">catch</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>Choice<b>&lt;</b><i>'x</i>, exn<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job and results in either the ordinary result of the job or the exception raised by the job.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.catch">catch</a> xJ <b>=</b> <a href="#def:val Hopac.Job.tryIn">tryIn</a> xJ (<a href="#def:val Hopac.Job.lift">lift</a> Choice1Of2) (<a href="#def:val Hopac.Job.lift">lift</a> Choice2Of2)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.forN" href="#dec:val Hopac.Job.forN">forN</a><b>:</b> int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job sequentially the given number of times.  The results from the jobs are ignored.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forN">forN</a> n xJ <b>=</b>
  <b>if</b> n <b>&gt;</b> 0 <b>then</b>
    xJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> _ <b>-&gt;</b> <a href="#def:val Hopac.Job.forN">forN</a> (n <b>-</b> 1) xJ
  <b>else</b>
    <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.unit">unit</a> ()
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.forUpTo" href="#dec:val Hopac.Job.forUpTo">forUpTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forUpTo">forUpTo</a>&nbsp;lo&nbsp;hi&nbsp;i2xJ</code> creates a job that sequentially iterates from <code>lo</code> to <code>hi</code> (inclusive) and calls the given function to construct jobs that will be executed.  The results from the jobs are ignored.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forUpTo">forUpTo</a> lo hi i2xJ <b>=</b>
  <b>if</b> lo <b>&lt;=</b> hi <b>then</b>
    i2xJ lo <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> _ <b>-&gt;</b> <a href="#def:val Hopac.Job.forUpTo">forUpTo</a> (lo <b>+</b> 1) hi i2xJ
  <b>else</b>
    <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.unit">unit</a> ()
</pre><p> Rationale: The reason for iterating over an inclusive range is to make this construct work like a <code><b>for</b>&nbsp;<b>...</b>&nbsp;<b>to</b>&nbsp;<b>...</b>&nbsp;<b>do</b>&nbsp;<b>...</b></code> loop of the base F# language.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forDownTo" href="#dec:val Hopac.Job.forDownTo">forDownTo</a><b>:</b> int <b>-&gt;</b> int <b>-&gt;</b> (int <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.forDownTo">forDownTo</a>&nbsp;hi&nbsp;lo&nbsp;i2xJ</code> creates a job that sequentially iterates from <code>hi</code> to <code>lo</code> (inclusive) and calls the given function to construct jobs that will be executed.  The results from the jobs are ignored.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forDownTo">forDownTo</a> hi lo i2xJ <b>=</b>
  <b>if</b> hi <b>&gt;=</b> lo <b>then</b>
    i2xJ hi <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> _ <b>-&gt;</b> <a href="#def:val Hopac.Job.forDownTo">forDownTo</a> (hi <b>-</b> 1) lo i2xJ
  <b>else</b>
    <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.unit">unit</a> ()
</pre><p> Rationale: The reason for iterating over an inclusive range is to make this construct work like a <code><b>for</b>&nbsp;<b>...</b>&nbsp;<b>downto</b>&nbsp;<b>...</b>&nbsp;<b>do</b>&nbsp;<b>...</b></code> loop of the base F# language.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.whileDo" href="#dec:val Hopac.Job.whileDo">whileDo</a><b>:</b> (unit <b>-&gt;</b> bool) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.whileDo">whileDo</a>&nbsp;u2b&nbsp;xJ</code> creates a job that sequentially executes the <code>xJ</code> job as long as <code>u2b&nbsp;()</code> returns <code><b>true</b></code>.  The results from the jobs are ignored.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.whileDo">whileDo</a> u2b xJ <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> <b>rec</b> loop () <b>=</b>
    <b>if</b> u2b () <b>then</b>
      xJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> _ <b>-&gt;</b> loop ()
    <b>else</b>
      <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.unit">unit</a> ()
  loop ()
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.whenDo" href="#dec:val Hopac.Job.whenDo">whenDo</a><b>:</b> bool <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> <code><a href="#def:val Hopac.Job.whenDo">whenDo</a>&nbsp;b&nbsp;uJ</code> is equivalent to <code><b>if</b>&nbsp;b&nbsp;<b>then</b>&nbsp;uJ&nbsp;<b>else</b>&nbsp;<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.unit">unit</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.forever" href="#dec:val Hopac.Job.forever">forever</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that repeats the given job indefinitely.  The results, if any, from the given job are ignored.  See also: <code><a href="#def:val Hopac.Job.foreverServer">foreverServer</a></code>, <code><a href="#def:val Hopac.Job.iterate">iterate</a></code>.</p><p> It is a common programming pattern to use server jobs that loop indefinitely and communicate with clients via channels.  When a job is blocked waiting for communication on one or more channels and the channels become garbage (no longer reachable by any other job) the job can be garbage collected as well.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.forever">forever</a> xJ <b>=</b> xJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> _ <b>-&gt;</b> <a href="#def:val Hopac.Job.forever">forever</a> xJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.iterate" href="#dec:val Hopac.Job.iterate">iterate</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that indefinitely iterates the given job constructor starting with the given value.  See also: <code><a href="#def:val Hopac.Job.iterateServer">iterateServer</a></code>, <code><a href="#def:val Hopac.Job.forever">forever</a></code>.</p><p> It is a common programming pattern to use server jobs that loop indefinitely and communicate with clients via channels.  When a job is blocked waiting for communication on one or more channels and the channels become garbage (no longer reachable by any other job) the job can be garbage collected as well.</p><p> Reference implementation:</p><pre><b>let</b> <b>rec</b> <a href="#def:val Hopac.Job.iterate">iterate</a> x x2xJ <b>=</b>
  x2xJ x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> x <b>-&gt;</b> <a href="#def:val Hopac.Job.iterate">iterate</a> x x2xJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.foreverServer" href="#dec:val Hopac.Job.foreverServer">foreverServer</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts a separate server job that repeats the given job indefinitely.  <code><a href="#def:val Hopac.Job.foreverServer">foreverServer</a>&nbsp;xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.forever">forever</a>&nbsp;xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.server">server</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.iterateServer" href="#dec:val Hopac.Job.iterateServer">iterateServer</a><b>:</b> <i>'x</i> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that starts a separate server job that indefinitely iterates the given job constructor starting with the given value.  <code><a href="#def:val Hopac.Job.iterateServer">iterateServer</a>&nbsp;x&nbsp;x2xJ</code> is equivalent to <code><a href="#def:val Hopac.Job.iterate">iterate</a>&nbsp;x&nbsp;x2xJ&nbsp;<b>|&gt;</b>&nbsp;<a href="#def:val Hopac.Job.server">server</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.seqCollect" href="#dec:val Hopac.Job.seqCollect">seqCollect</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs in sequence and returns a list of the results.  See also: <code><a href="#def:val Hopac.Job.seqIgnore">seqIgnore</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.seqCollect">seqCollect</a> (xJs<b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> xs <b>=</b> ResizeArray<b>&lt;</b>_<b>&gt;</b>()
  <b>let</b> xJs <b>=</b> xJs<b>.</b>GetEnumerator ()
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xJs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    xJs<b>.</b>Current <a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a> xs<b>.</b>Add) <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a>
  xs
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.seqIgnore" href="#dec:val Hopac.Job.seqIgnore">seqIgnore</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs in sequence.  The results of the jobs are ignored.  See also: <code><a href="#def:val Hopac.Job.seqCollect">seqCollect</a></code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.seqIgnore">seqIgnore</a> (xJs<b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> xJs <b>=</b> xJs<b>.</b>GetEnumerator ()
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xJs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    xJs<b>.</b>Current)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.conCollect" href="#dec:val Hopac.Job.conCollect">conCollect</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs as separate concurrent jobs and returns a list of the results.</p><p> Note that when multiple jobs raise exceptions, then the created job raises an <code>AggregateException</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.conIgnore" href="#dec:val Hopac.Job.conIgnore">conIgnore</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish.  The results of the jobs are ignored.</p><p> Note that when multiple jobs raise exceptions, then the created job raises an <code>AggregateException</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Job.fromBeginEnd" href="#dec:val Hopac.Job.fromBeginEnd">fromBeginEnd</a><b>:</b> (AsyncCallback <b>*</b> obj <b>-&gt;</b> IAsyncResult)
               <b>-&gt;</b> (IAsyncResult <b>-&gt;</b> <i>'x</i>)
               <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that performs the asynchronous operation defined by the given pair of begin and end operations.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a> doBegin doEnd <b>=</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.scheduler">scheduler</a> () <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> sr <b>-&gt;</b>
  <b>let</b> xI <b>=</b> <a href="#def:val Hopac.TopLevel.ivar">ivar</a> ()
  doBegin <b>&lt;|</b> AsyncCallback (<b>fun</b> ar <b>-&gt;</b>
    <a href="#def:module Hopac.Scheduler">Scheduler</a><b>.</b><a href="#def:val Hopac.Scheduler.start">start</a> sr (<b>try</b> xI <a href="#def:val Hopac.Infixes.&lt;-="><-=</a> doEnd ar <b>with</b> e <b>-&gt;</b> xI <a href="#def:val Hopac.Infixes.&lt;-=!"><-=!</a> e))
  <b>|&gt;</b> ignore
  <b>upcast</b> xI
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Job.scheduler" href="#dec:val Hopac.Job.scheduler">scheduler</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Scheduler">Scheduler</a><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a job that returns the scheduler under which the job is being run. This allows interfacing Hopac with existing asynchronous operations that do not fall into a pattern that is already supported explicitly.  See, for example, the reference implementation of <code><a href="#def:val Hopac.Job.fromBeginEnd">fromBeginEnd</a></code>.  The key is that the job that is suspended for the duration of the asynchronous operation can then be resumed on the same scheduler.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Alt" href="#dec:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a first-class synchronous operation.</p><p> The inspiration for alternatives comes from the events of Concurrent ML. The term ''alternative'' was chosen, because the term ''event'' is already widely used in .Net.</p><p> Simpler forms of selective synchronization exists in various languages.  For example, the occam language has an <code>alt</code> statement and the Go language has a <code><a href="#def:val Hopac.Alt.select">select</a></code> statement.  In Hopac and Concurrent ML, selective synchronous operations are not limited to primitive message passing operations (see <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Ch.Alt.give">give</a></code> and <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Ch.Alt.take">take</a></code>), but are instead first-class values (see <code><a href="#def:val Hopac.Alt.choose">choose</a></code>) and can be extended with user-defined code (see <code><a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a></code> and <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>) allowing the encapsulation of concurrent protocols as selective synchronous operations.</p><p> Note that <code><a href="#def:type Hopac.Alt">Alt</a></code> is a subtype of <code><a href="#def:type Hopac.Job">Job</a></code>.  You can use an alternative in any context that requires a job and <code>xA&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;<b>...</b></code> is equivalent to <code><a href="#def:val Hopac.Alt.pick">pick</a>&nbsp;xA&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;<b>...</b></code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Alt" href="#dec:module Hopac.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on first-class synchronous operations or alternatives.<pre><b>val</b> <a id="def:val Hopac.Alt.always" href="#dec:val Hopac.Alt.always">always</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is always available for picking and results in the given value.</p><p> Note that when there are alternatives immediately available for picking in a choice, the first such alternative will be committed to.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.unit" href="#dec:val Hopac.Alt.unit">unit</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns an alternative that is always available for picking and results in the unit value.  <code><a href="#def:val Hopac.Alt.unit">unit</a>&nbsp;()</code> is an optimized version of <code><a href="#def:val Hopac.Alt.always">always</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.never" href="#dec:val Hopac.Alt.never">never</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is never available for picking.</p><p> Note that <code><a href="#def:val Hopac.Alt.pick">pick</a>&nbsp;(<a href="#def:val Hopac.Alt.never">never</a>&nbsp;())</code> is equivalent to <code><a href="#def:val Hopac.Job.abort">abort</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.zero" href="#dec:val Hopac.Alt.zero">zero</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Return an alternative that is never available for picking.  <code><a href="#def:val Hopac.Alt.zero">zero</a>&nbsp;()</code> is an optimized version of <code><a href="#def:val Hopac.Alt.never">never</a>&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.guard" href="#dec:val Hopac.Alt.guard">guard</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the given job.  See also: <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>.</p><p> <code><a href="#def:val Hopac.Alt.guard">guard</a></code> allows client-server protocols that do not require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.  For example, the given job may create and send a request to a server and then return an alternative that waits for the server's reply.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.guard">guard</a> xAJ <b>=</b> <a href="#def:val Hopac.Alt.withNack">withNack</a> <b>&lt;|</b> <b>fun</b> _ <b>-&gt;</b> xAJ
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.delay" href="#dec:val Hopac.Alt.delay">delay</a><b>:</b> (unit <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the given thunk.</p><p> <code><a href="#def:val Hopac.Alt.delay">delay</a></code> is an optimized weaker form of <code><a href="#def:val Hopac.Alt.guard">guard</a></code> that can be used when no concurrent operations beyond the returned alternative are required by the encapsulated request protocol.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.delay">delay</a> u2xA <b>=</b> <a href="#def:val Hopac.Alt.guard">guard</a> (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.thunk">thunk</a> u2xA)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Alt.withNack" href="#dec:val Hopac.Alt.withNack">withNack</a><b>:</b> (<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is computed at instantiation time with the given job constructed with a negative acknowledgment alternative.  See also: <code><a href="#def:val Hopac.Alt.guard">guard</a></code>.</p><p> <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> allows client-server protocols that do require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.  The negative acknowledgment alternative will be available for picking in case some other instantiated alternative involved in the choice is committed to instead.</p><p> Like <code><a href="#def:val Hopac.Alt.guard">guard</a></code>, <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> is typically used to encapsulate the client side operation of a concurrent protocol.  The client side operation typically constructs a request, containing the negative acknowledgment alternative, sends it to a server and then returns an alternative that waits for a rendezvous with the server.  In case the client later commits to some other alternative, the negative acknowledgment token becomes pickable and the server can also abort the operation.</p><p> Note that if an alternative created with <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> is not instantiated, then no negative acknowledgment is created.  For example, given an alternative of the form <code><a href="#def:val Hopac.Alt.always">always</a>&nbsp;()&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;"><|></a>&nbsp;<a href="#def:val Hopac.Alt.withNack">withNack</a>&nbsp;(<b>...</b>)</code> the <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code> alternative is never instantiated.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.choose" href="#dec:val Hopac.Alt.choose">choose</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is available for picking when any one of the given alternatives is.  See also: <code><a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;"><|></a></code>.</p><p> Note that <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[]</code> is equivalent to <code><a href="#def:val Hopac.Alt.never">never</a>&nbsp;()</code> and <code><a href="#def:val Hopac.Alt.pick">pick</a>&nbsp;(<a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[])</code> is equivalent to <code><a href="#def:val Hopac.Job.abort">abort</a>&nbsp;()</code>.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Alt.choose">choose</a> xAs <b>=</b> <a href="#def:module Hopac.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Alt.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  Seq<b>.</b>foldBack (<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;"><|></a>) xAs (<a href="#def:val Hopac.Alt.never">never</a> ())
</pre><p> Above, <code>Seq<b>.</b>foldBack</code> has the obvious meaning.  Alternatively we could define <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;"><|></a>&nbsp;xA2</code> to be equivalent to <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[xA1;&nbsp;xA2]</code> and consider <code><a href="#def:val Hopac.Alt.choose">choose</a></code> as primitive.</div>
<pre><b>module</b> <a id="def:module Hopac.Alt.Infixes" href="#dec:module Hopac.Alt.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Infix operators on alternatives.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&lt;|&gt;" href="#dec:val Hopac.Alt.Infixes.&lt;|&gt;">&lt;|&gt;</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that is available for picking when either of the given alternatives is available.  <code>xA1&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;"><|></a>&nbsp;xA2</code> is an optimized version of <code><a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;[xA1;&nbsp;xA2]</code>.</p><p> The given alternatives are processed in a left-to-right order with short-cut evaluation.  In other words, given an alternative of the form <code>first&nbsp;<a href="#def:val Hopac.Alt.Infixes.&lt;|&gt;"><|></a>&nbsp;second</code>, the <code>first</code> alternative is first instantiated and, if it is pickable, is committed to and the <code>second</code> alternative will not be instantiated at all.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;=?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;=?">&gt;&gt;=?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative whose result is passed to the given job constructor and processed with the resulting job after the given alternative has been committed to.</p><p> Note that although this operator has a type similar to a monadic bind operation, alternatives do not form a monad (with the <code><a href="#def:val Hopac.Alt.always">always</a></code> alternative constructor).  So called Transactional Events do form a monad, but require a more complex synchronization protocol.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;.?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;.?">&gt;&gt;.?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;.?">>>.?</a>&nbsp;yJ</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;yJ</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes..&gt;&gt;?" href="#dec:val Hopac.Alt.Infixes..&gt;&gt;?">.&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes..&gt;&gt;?">.>>?</a>&nbsp;yJ</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a>&nbsp;<b>fun</b>&nbsp;x&nbsp;<b>-&gt;</b>&nbsp;yJ&nbsp;<a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a>&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.|&gt;&gt;?" href="#dec:val Hopac.Alt.Infixes.|&gt;&gt;?">|&gt;&gt;?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.|&gt;&gt;?">|>>?</a>&nbsp;x2y</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a>&nbsp;(x2y&nbsp;<b>&gt;&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>)</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;%?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;%?">&gt;&gt;%?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;%?">>>%?</a>&nbsp;y</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:val Hopac.Job.result">result</a>&nbsp;y</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Alt.Infixes.&gt;&gt;!?" href="#dec:val Hopac.Alt.Infixes.&gt;&gt;!?">&gt;&gt;!?</a>)<b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>_<b>&gt;</b>
</pre>
<div class="nested"><p> <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;!?">>>!?</a>&nbsp;e</code> is equivalent to <code>xA&nbsp;<a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a>&nbsp;<b>fun</b>&nbsp;_&nbsp;<b>-&gt;</b>&nbsp;raise&nbsp;e</code>.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.tryIn" href="#dec:val Hopac.Alt.tryIn">tryIn</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> (exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Implements the try-in-unless exception handling construct for alternatives.  Both of the continuation jobs <code><i>'x</i>&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for success, and <code>exn&nbsp;<b>-&gt;</b>&nbsp;<a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b></code>, for failure, are invoked from a tail position.</p><p> Exceptions from both before and after the commit point can be handled.  An exception that occurs before a commit point, from the user code in a <code><a href="#def:val Hopac.Alt.guard">guard</a></code>, <code><a href="#def:val Hopac.Alt.delay">delay</a></code>, or <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>, results in treating that exception as the commit point.</p><p> Note you can also use function or job level exception handling before the commit point within the user code in a <code><a href="#def:val Hopac.Alt.guard">guard</a></code>, <code><a href="#def:val Hopac.Alt.delay">delay</a></code>, or <code><a href="#def:val Hopac.Alt.withNack">withNack</a></code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.pick" href="#dec:val Hopac.Alt.pick">pick</a><b>:</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that instantiates the alternative, waits until it becomes available for picking and then commits to the alternative and results in its value.  This function is a NOP and is provided as a kind of syntactic alternative to using a type ascription or a type cast.</div>
<pre><b>val</b> <a id="def:val Hopac.Alt.select" href="#dec:val Hopac.Alt.select">select</a><b>:</b> seq<b>&lt;</b><a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that instantiates the given sequence of alternatives one-by-one, waits until at least one of them becomes available for picking and then commits to the alternative resulting in its value.  <code><a href="#def:val Hopac.Alt.select">select</a>&nbsp;xAs</code> is equivalent to <code><a href="#def:val Hopac.Alt.pick">pick</a>&nbsp;(<a href="#def:val Hopac.Alt.choose">choose</a>&nbsp;xAs)</code>.</p><p> Note that <code><a href="#def:val Hopac.Alt.select">select</a>&nbsp;[]</code> is equivalent to <code><a href="#def:val Hopac.Job.abort">abort</a>&nbsp;()</code>.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Timer" href="#dec:module Hopac.Timer">Timer</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on a wall-clock timer.<pre><b>module</b> <a id="def:module Hopac.Timer.Global" href="#dec:module Hopac.Timer.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global wall-clock timer.  The global timer is implicitly associated with the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Timer.Global.timeOut" href="#dec:val Hopac.Timer.Global.timeOut">timeOut</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, after instantiation, becomes pickable after the specified time span.</p><p> Note that this is simply not intended for high precision timing and the resolution of the underlying timing mechanism is very coarse (Windows system ticks).</p><p> Note that you do not need to create a new timeout alternative every time you need a timeout with a specific time span.</p><p> For example, you can create a timeout for one second</p><pre><b>let</b> after1s <b>=</b> <a href="#def:val Hopac.Timer.Global.timeOut">timeOut</a> (TimeSpan<b>.</b>FromSeconds 1.0)
</pre><p> and then use that timeout many times</p><pre><a href="#def:val Hopac.Alt.select">select</a> [
  makeRequest <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a> <b>fun</b> rp <b>-&gt;</b> <b>...</b>
  after1s     <a href="#def:val Hopac.Alt.Infixes.&gt;&gt;=?">>>=?</a> <b>fun</b> () <b>-&gt;</b> <b>...</b>
]
</pre><p> Timeouts, like other alternatives, can also directly be used as job level operations.  For example, using the above definition of <code>after1s</code></p><pre>after1s <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> () <b>-&gt;</b> <b>...</b>
</pre><p> has the same effect as invoking <code><a href="#def:val Hopac.Timer.Global.sleep">sleep</a></code> with a time span of one second.</div>
<pre><b>val</b> <a id="def:val Hopac.Timer.Global.sleep" href="#dec:val Hopac.Timer.Global.sleep">sleep</a><b>:</b> TimeSpan <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sleeps for (about) the specified time.  Note that this is simply not intended for high precision timing and the resolution of the underlying timing mechanism is coarse (Windows system ticks). See also: <code><a href="#def:val Hopac.Timer.Global.timeOut">timeOut</a></code>.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Ch" href="#dec:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a synchronous channel.</p><p> Channels provide a simple rendezvous mechanism for concurrent jobs and are designed to be used as the building blocks of selective synchronous abstractions.</p><p> Channels are lightweight objects and it is common to allocate fresh channels for short-term, possibly even one-shot, communications.  When simple rendezvous is not needed in a one-shot communication, a write once variable, <code><a href="#def:type Hopac.IVar">IVar</a></code>, may offer slightly better performance.</p><p> Channels are optimized for synchronous message passing, which can often be done without buffering.  Channels also provide an asynchronous <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a></code> operation, but for situations where buffering is needed some other message passing mechanism is likely to perform better.</p><p> Note that <code><a href="#def:type Hopac.Ch">Ch</a></code> is a subtype of <code><a href="#def:type Hopac.Alt">Alt</a></code> and <code>xCh&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Ch.Alt.take">take</a>&nbsp;xCh</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.Ch" href="#dec:module Hopac.Ch">Ch</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on synchronous channels.<pre><b>module</b> <a id="def:module Hopac.Ch.Now" href="#dec:module Hopac.Ch.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on synchronous channels.<pre><b>val</b> <a id="def:val Hopac.Ch.Now.create" href="#dec:val Hopac.Ch.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new channel.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Ch.Global" href="#dec:module Hopac.Ch.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations bound to the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Ch.Global.send" href="#dec:val Hopac.Ch.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sends the given value to the specified channel.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a></code> instead.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.create" href="#dec:val Hopac.Ch.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new channel.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.give" href="#dec:val Hopac.Ch.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that offers to give the given value to another job on the given channel.  A give operation is synchronous.  In other words, a give operation waits until another job takes the value.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.send" href="#dec:val Hopac.Ch.send">send</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends a value to another job on the given channel.  A send operation is asynchronous.  In other words, a send operation does not wait for another job to give the value to.</p><p> Note that channels have been optimized for synchronous operations; an occasional send can be efficient, but when sends are queued, performance maybe be significantly worse than with a <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code> optimized for buffering.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.take" href="#dec:val Hopac.Ch.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that offers to take a value from another job on the given channel.  In other words, a take operation waits until another job gives (or sends) a value.</div>
<pre><b>module</b> <a id="def:module Hopac.Ch.Alt" href="#dec:module Hopac.Ch.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Selective operations on synchronous channels.<pre><b>val</b> <a id="def:val Hopac.Ch.Alt.give" href="#dec:val Hopac.Ch.Alt.give">give</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available for picking when another job offers to take the value.</div>
<pre><b>val</b> <a id="def:val Hopac.Ch.Alt.take" href="#dec:val Hopac.Ch.Alt.take">take</a><b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, at instantiation time, offers to take a value from another job on the given channel, and becomes available for picking when another job offers to give a value.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.IVar" href="#dec:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a write once variable.</p><p> Write once variables are designed for and most commonly used for getting replies from concurrent servers and asynchronous operations, but can also be useful for other purposes such as for one-shot events and for implementing incremental, but immutable, concurrent data structures.</p><p> Because it is common to need to be able to communicate either an expected successful result or an exceptional failure in typical use cases of write once variables, direct mechanisms are provided for both.  The implementation is optimized in such a way that the ability to report an exceptional failure does not add overhead to the expected successful usage scenarios.</p><p> Write once variables are lightweight objects and it is typical to always just create a new write once variable when one is needed.  In most cases, a write once variable will be slightly more lightweight than a channel.  This is possible because write once variables do not support simple rendezvous like channels do.  When simple rendezvous is necessary, a channel should be used instead.</p><p> Note that <code><a href="#def:type Hopac.IVar">IVar</a></code> is a subtype of <code><a href="#def:type Hopac.Alt">Alt</a></code> and <code>xI&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is equivalent to <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:module Hopac.IVar.Alt">Alt</a><b>.</b><a href="#def:val Hopac.IVar.Alt.read">read</a>&nbsp;xI</code>.</div>
<pre><b>module</b> <a id="def:module Hopac.IVar" href="#dec:module Hopac.IVar">IVar</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on write once variables.<pre><b>module</b> <a id="def:module Hopac.IVar.Now" href="#dec:module Hopac.IVar.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on write once variables.<pre><b>val</b> <a id="def:val Hopac.IVar.Now.create" href="#dec:val Hopac.IVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new write once variable.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.create" href="#dec:val Hopac.IVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new write once variable.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.fill" href="#dec:val Hopac.IVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given value to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.fillFailure" href="#dec:val Hopac.IVar.fillFailure">fillFailure</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given exception to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.</div>
<pre><b>val</b> <a id="def:val Hopac.IVar.read" href="#dec:val Hopac.IVar.read">read</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that, if necessary, waits until the given write once variable is written to and then returns the written value or fails with the exception written to the variable.</div>
<pre><b>module</b> <a id="def:module Hopac.IVar.Alt" href="#dec:module Hopac.IVar.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Selective operations on write once variables.<pre><b>val</b> <a id="def:val Hopac.IVar.Alt.read" href="#dec:val Hopac.IVar.Alt.read">read</a><b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available for picking after the write once variable has been written to.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.MVar" href="#dec:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a serialized variable.</p><p> Serialized variables, or variables for short, can be used in situations where multiple concurrent jobs need serialized access to shared state.</p><p> A serialized variable can be either empty or full.  When an attempt is made to take the value of an empty variable, the job is suspended until some other job fills the variable with a value.  Serialized variables are designed to be used in such a way that the variable acts as a mechanism for passing a permission token, the value contained by the variable, from one concurrent job to another.  Only the concurrent job that holds the token is allowed to fill the variable.  When used in this way, operations on the variable appear as atomic and access to the state will be serialized.</p><p> Note that <code><a href="#def:type Hopac.MVar">MVar</a></code> is a subtype of <code><a href="#def:type Hopac.Alt">Alt</a></code> and <code>xM&nbsp;<b>:&gt;</b>&nbsp;<a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> is equivalent to <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:module Hopac.MVar.Alt">Alt</a><b>.</b><a href="#def:val Hopac.MVar.Alt.take">take</a>&nbsp;xM</code>.</p><p> Note that if you are familiar with the MVar abstraction provided by Concurrent Haskell, then it is important to realize that the semantics and intended usage of Hopac's and Concurrent ML's <code><a href="#def:type Hopac.MVar">MVar</a></code> are quite different.</div>
<pre><b>module</b> <a id="def:module Hopac.MVar" href="#dec:module Hopac.MVar">MVar</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on serialized variables.<pre><b>module</b> <a id="def:module Hopac.MVar.Now" href="#dec:module Hopac.MVar.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on serialized variables.<pre><b>val</b> <a id="def:val Hopac.MVar.Now.create" href="#dec:val Hopac.MVar.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new serialized variable that is initially empty.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.Now.createFull" href="#dec:val Hopac.MVar.Now.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new serialized variable that initially contains the given value.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.create" href="#dec:val Hopac.MVar.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new serialized variable that is initially empty.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.createFull" href="#dec:val Hopac.MVar.createFull">createFull</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new serialized variable that initially contains the given value.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.fill" href="#dec:val Hopac.MVar.fill">fill</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given value to the serialized variable.  It is an error to write to a <code><a href="#def:type Hopac.MVar">MVar</a></code> that is full.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.take" href="#dec:val Hopac.MVar.take">take</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits until the serialized variable contains a value and then takes the value contained by the variable leaving the variable empty.</div>
<pre><b>val</b> <a id="def:val Hopac.MVar.modifyFun" href="#dec:val Hopac.MVar.modifyFun">modifyFun</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'x</i> <b>*</b> <i>'y</i>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that takes the value of the serialized variable and then fills the variable with the result of performing the given function.</p><p> Note that this operation is not atomic as such.  However, it is a common programming pattern to make it so that only the job that has emptied an <code><a href="#def:type Hopac.MVar">MVar</a></code> by taking a value from it is allowed to fill the <code><a href="#def:type Hopac.MVar">MVar</a></code>.  Such an access pattern makes operations on the <code><a href="#def:type Hopac.MVar">MVar</a></code> appear as atomic.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.MVar.modifyFun">modifyFun</a> (x2xy<b>:</b> <i>'x</i> <b>-&gt;</b> <i>'x</i> <b>*</b> <i>'y</i>) (xM<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b>
  xM <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> (x2xy <b>&gt;&gt;</b> <b>fun</b> (x, y) <b>-&gt;</b> <a href="#def:val Hopac.MVar.fill">fill</a> xM x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a> y)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.MVar.modifyJob" href="#dec:val Hopac.MVar.modifyJob">modifyJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that takes the value of the serialized variable and then fills the variable with the result of performing the given job.</p><p> Note that this operation is not atomic as such.  However, it is a common programming pattern to make it so that only the job that has emptied an <code><a href="#def:type Hopac.MVar">MVar</a></code> by taking a value from it is allowed to fill the <code><a href="#def:type Hopac.MVar">MVar</a></code>.  Such an access pattern makes operations on the <code><a href="#def:type Hopac.MVar">MVar</a></code> appear as atomic.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.MVar.modifyJob">modifyJob</a> (x2xyJ<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i> <b>*</b> <i>'y</i><b>&gt;</b>) (xM<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b>
  xM <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> x2xyJ <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> (x, y) <b>-&gt;</b> <a href="#def:val Hopac.MVar.fill">fill</a> xM x <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a> y
</pre></div>
<pre><b>module</b> <a id="def:module Hopac.MVar.Alt" href="#dec:module Hopac.MVar.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Selective operations on serialized variables.<pre><b>val</b> <a id="def:val Hopac.MVar.Alt.take" href="#dec:val Hopac.MVar.Alt.take">take</a><b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available for picking when the variable contains a value and, if committed to, takes the value from the variable.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Mailbox" href="#dec:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a asynchronous, unbounded buffered mailbox.</div>
<pre><b>module</b> <a id="def:module Hopac.Mailbox" href="#dec:module Hopac.Mailbox">Mailbox</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on buffered mailboxes.<pre><b>module</b> <a id="def:module Hopac.Mailbox.Now" href="#dec:module Hopac.Mailbox.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on buffered mailboxes.<pre><b>val</b> <a id="def:val Hopac.Mailbox.Now.create" href="#dec:val Hopac.Mailbox.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a new mailbox.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Mailbox.Global" href="#dec:module Hopac.Mailbox.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations bound to the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Mailbox.Global.send" href="#dec:val Hopac.Mailbox.Global.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sends the given value to the specified mailbox.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:val Hopac.Mailbox.send">send</a></code> instead.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Mailbox.create" href="#dec:val Hopac.Mailbox.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new mailbox.</div>
<pre><b>val</b> <a id="def:val Hopac.Mailbox.send" href="#dec:val Hopac.Mailbox.send">send</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends the given value to the specified mailbox.  This operation never blocks.</div>
<pre><b>val</b> <a id="def:val Hopac.Mailbox.take" href="#dec:val Hopac.Mailbox.take">take</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits until the specified mailbox contains at least one value and then takes a value from the mailbox and returns it.  Values are taken in FIFO order.</div>
<pre><b>module</b> <a id="def:module Hopac.Mailbox.Alt" href="#dec:module Hopac.Mailbox.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Selective operations on buffered mailboxes.<pre><b>val</b> <a id="def:val Hopac.Mailbox.Alt.take" href="#dec:val Hopac.Mailbox.Alt.take">take</a><b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that becomes available for picking when the mailbox contains at least one value and, if committed to, takes a value from the mailbox.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Promise" href="#dec:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>:&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a lazy promise or eager future depending on construction.</p><p> Promises are used when a parallel job is started for the purpose of computing a result.  When multiple parallel jobs need to be started to compute results in parallel in regular patterns, combinators such as <code><a href="#def:val Hopac.Job.Infixes.&lt;*&gt;"><*></a></code>, <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.conCollect">conCollect</a></code> and <code><a href="#def:module Hopac.Extensions.Seq">Seq</a><b>.</b><a href="#def:module Hopac.Extensions.Seq.Con">Con</a><b>.</b><a href="#def:val Hopac.Extensions.Seq.Con.mapJob">mapJob</a></code> may be easier to use and provide improved performance.</div>
<pre><b>module</b> <a id="def:module Hopac.Promise" href="#dec:module Hopac.Promise">Promise</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on promises.<pre><b>module</b> <a id="def:module Hopac.Promise.Now" href="#dec:module Hopac.Promise.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on promises.<pre><b>val</b> <a id="def:val Hopac.Promise.Now.delay" href="#dec:val Hopac.Promise.Now.delay">delay</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a promise whose value is computed lazily with the given job when an attempt is made to read the promise.  Although the job is not started immediately, the effect is that the delayed job will be run as a separate job, which means it is possible to communicate with it as long the delayed job is started before trying to communicate with it.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.Now.withValue" href="#dec:val Hopac.Promise.Now.withValue">withValue</a><b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a promise with the given value.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.Now.withFailure" href="#dec:val Hopac.Promise.Now.withFailure">withFailure</a><b>:</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a promise with the given failure exception.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.start" href="#dec:val Hopac.Promise.start">start</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a promise, whose value is computed eagerly with the given job, which is started to run as a separate concurrent job.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.delay" href="#dec:val Hopac.Promise.delay">delay</a><b>:</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a promise, whose value is computed with the given job, when an attempt is made to read the promise.  Although the job is not started immediately, the effect is that the delayed job will be run as a separate job, which means it is possible to communicate with it as long the delayed job is started before trying to communicate with it.</div>
<pre><b>val</b> <a id="def:val Hopac.Promise.read" href="#dec:val Hopac.Promise.read">read</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits for the promise to be computed and then returns its value (or fails with exception).  If the promise was delayed, it is started as a separate job.</div>
<pre><b>module</b> <a id="def:module Hopac.Promise.Alt" href="#dec:module Hopac.Promise.Alt">Alt</a> <b>=</b>
</pre>
<div class="nested"><p> Selective operations on promises.<pre><b>val</b> <a id="def:val Hopac.Promise.Alt.read" href="#dec:val Hopac.Promise.Alt.read">read</a><b>:</b> <a href="#def:type Hopac.Promise">Promise</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative for reading the promise.  If the promise was delayed, it is started as a separate job.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Lock" href="#dec:type Hopac.Lock">Lock</a>
</pre>
<div class="nested"><p> A non-recursive mutual exclusion lock for jobs.</p><p> In most cases you should use higher-level message passing primitives such as <code><a href="#def:type Hopac.Ch">Ch</a></code>, <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code>, <code><a href="#def:type Hopac.MVar">MVar</a></code> or <code><a href="#def:type Hopac.IVar">IVar</a></code>, but in some cases a simple lock might be more natural to use.</p><p> Note that this lock is for synchronizing at the level of jobs.  A job may even block while holding the lock.  For short non-blocking critical sections, native locks (e.g. <code>Monitor</code> and <code>SpinLock</code>), concurrent data structures or interlocked operations should be faster.  On the other hand, suspending and resuming a job is several orders of magnitude faster than suspending and resuming a native thread.</div>
<pre><b>module</b> <a id="def:module Hopac.Lock" href="#dec:module Hopac.Lock">Lock</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on mutual exclusion locks.<pre><b>module</b> <a id="def:module Hopac.Lock.Now" href="#dec:module Hopac.Lock.Now">Now</a> <b>=</b>
</pre>
<div class="nested"><p> Immediate or non-workflow operations on locks.<pre><b>val</b> <a id="def:val Hopac.Lock.Now.create" href="#dec:val Hopac.Lock.Now.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Lock">Lock</a>
</pre>
<div class="nested"><p> Creates a new lock.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Lock.create" href="#dec:val Hopac.Lock.create">create</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Lock">Lock</a><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that creates a new mutual exclusion lock.</div>
<pre><b>val</b> <a id="def:val Hopac.Lock.duringFun" href="#dec:val Hopac.Lock.duringFun">duringFun</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> (unit <b>-&gt;</b> <i>'x</i>) <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that calls the given function so that the lock is held during the execution of the function.</div>
<pre><b>val</b> <a id="def:val Hopac.Lock.duringJob" href="#dec:val Hopac.Lock.duringJob">duringJob</a><b>:</b> <a href="#def:type Hopac.Lock">Lock</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that runs the given job so that the lock is held during the execution of the given job.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Extensions" href="#dec:module Hopac.Extensions">Extensions</a> <b>=</b>
</pre>
<div class="nested"><p> Extensions to various system modules and types for programming with jobs. You can open this module to use the extensions much like as if they were part of the existing modules and types.<pre><b>module</b> <a id="def:module Hopac.Extensions.Array" href="#dec:module Hopac.Extensions.Array">Array</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for processing arrays with jobs.<pre><b>val</b> <a id="def:val Hopac.Extensions.Array.mapJob" href="#dec:val Hopac.Extensions.Array.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>array<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Sequentially maps the given job constructor to the elements of the array and returns an array of the results.  <code><a href="#def:module Hopac.Extensions.Array">Array</a><b>.</b><a href="#def:val Hopac.Extensions.Array.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs</code> is an optimized version of <code><a href="#def:module Hopac.Extensions.Seq">Seq</a><b>.</b><a href="#def:val Hopac.Extensions.Seq.mapJob">mapJob</a>&nbsp;x2yJ&nbsp;xs&nbsp;<a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a>&nbsp;<b>fun</b>&nbsp;ys&nbsp;<b>-&gt;</b>&nbsp;ys<b>.</b>ToArray&nbsp;()</code>.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Array.iterJob" href="#dec:val Hopac.Extensions.Array.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> array<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Sequentially iterates the given job constructor over the given array. The results, if any, of the jobs are ignored.  <code><a href="#def:module Hopac.Extensions.Array">Array</a><b>.</b><a href="#def:val Hopac.Extensions.Array.iterJob">iterJob</a>&nbsp;x2yJ&nbsp;xs</code> is an optimized version of <code><a href="#def:module Hopac.Extensions.Seq">Seq</a><b>.</b><a href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a>&nbsp;x2yJ&nbsp;xs</code>.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Extensions.Seq" href="#dec:module Hopac.Extensions.Seq">Seq</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for processing sequences with jobs.<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.iterJob" href="#dec:val Hopac.Extensions.Seq.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Sequentially iterates the given job constructor over the given sequence. The results, if any, of the jobs are ignored.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Extensions.Seq.iterJob">iterJob</a> x2yJ (xs<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> xs <b>=</b> xs<b>.</b>GetEnumerator ()
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    x2yJ xs<b>.</b>Current)
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.mapJob" href="#dec:val Hopac.Extensions.Seq.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Sequentially maps the given job constructor to the elements of the sequence and returns a list of the results.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Extensions.Seq.mapJob">mapJob</a> x2yJ (xs<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> ys <b>=</b> ResizeArray<b>&lt;</b>_<b>&gt;</b>()
  <b>let</b> xs <b>=</b> xs<b>.</b>GetEnumerator ()
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.whileDo">whileDo</a> xs<b>.</b>MoveNext (<a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
    x2yJ xs<b>.</b>Current <a href="#def:val Hopac.Job.Infixes.|&gt;&gt;">|>></a> ys<b>.</b>Add) <a href="#def:val Hopac.Job.Infixes.&gt;&gt;%">>>%</a>
  ys
</pre></div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.foldJob" href="#dec:val Hopac.Extensions.Seq.foldJob">foldJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <i>'y</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> seq<b>&lt;</b><i>'y</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Sequentially folds the job constructor over the given sequence and returns the result of the fold.</p><p> Reference implementation:</p><pre><b>let</b> <a href="#def:val Hopac.Extensions.Seq.foldJob">foldJob</a> xy2xJ x (ys<b>:</b> seq<b>&lt;</b><i>'y</i><b>&gt;</b>) <b>=</b> <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.delay">delay</a> <b>&lt;|</b> <b>fun</b> () <b>-&gt;</b>
  <b>let</b> ys <b>=</b> ys<b>.</b>GetEnumerator ()
  <b>let</b> <b>rec</b> loop x <b>=</b>
    <b>if</b> ys<b>.</b>MoveNext () <b>then</b>
      xy2xJ x ys<b>.</b>Current <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> loop
    <b>else</b>
      <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.result">result</a> x
  loop x
</pre></div>
<pre><b>module</b> <a id="def:module Hopac.Extensions.Seq.Con" href="#dec:module Hopac.Extensions.Seq.Con">Con</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for processing sequences using concurrent jobs.<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.Con.iterJob" href="#dec:val Hopac.Extensions.Seq.Con.iterJob">iterJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Iterates the given job constructor over the given sequence, runs the constructed jobs as separate concurrent jobs and waits until all of the jobs have finished.  The results of the created jobs are ignored.</div>
<pre><b>val</b> <a id="def:val Hopac.Extensions.Seq.Con.mapJob" href="#dec:val Hopac.Extensions.Seq.Con.mapJob">mapJob</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Iterates the given job constructor over the given sequence, runs the constructed jobs as separate concurrent jobs and waits until all of the jobs have finished collecting the results into a list.</div>
</div>
</div>
<pre><b>[&lt;</b>Sealed<b>&gt;]</b> 
<b>type</b> <a id="def:type Hopac.Extensions.Task" href="#dec:type Hopac.Extensions.Task">Task</a> <b>=</b>
</pre>
<div class="nested"><p> Operations for interfacing tasks with jobs.<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.awaitJob" href="#dec:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> Threading<b>.</b>Tasks<b>.</b>Task<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits for the given task to finish and then returns the result of the task.  Note that this does not start the task.</p><p> Reference implementation:</p><pre><b>let</b> awaitJob (xT<b>:</b> Threading<b>.</b>Tasks<b>.</b>Task<b>&lt;</b><i>'x</i><b>&gt;</b>) <b>=</b>
  <a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.scheduler">scheduler</a> () <a href="#def:val Hopac.Job.Infixes.&gt;&gt;=">>>=</a> <b>fun</b> sr <b>-&gt;</b>
  <b>let</b> xI <b>=</b> <a href="#def:val Hopac.TopLevel.ivar">ivar</a> ()
  xT<b>.</b>ContinueWith (Action<b>&lt;</b>Threading<b>.</b>Tasks<b>.</b>Task<b>&gt;</b>(<b>fun</b> _ <b>-&gt;</b>
    <a href="#def:module Hopac.Scheduler">Scheduler</a><b>.</b><a href="#def:val Hopac.Scheduler.start">start</a> sr (<b>try</b> xI <a href="#def:val Hopac.Infixes.&lt;-="><-=</a> xT<b>.</b>Result <b>with</b> e <b>-&gt;</b> xI <a href="#def:val Hopac.Infixes.&lt;-=!"><-=!</a> e)))
  <b>|&gt;</b> ignore
  <b>upcast</b> xI
</pre></div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Extensions.Task.awaitJob" href="#dec:static member Hopac.Extensions.Task.awaitJob">awaitJob</a><b>:</b> Threading<b>.</b>Tasks<b>.</b>Task <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that waits until the given task finishes.  Note that this does not start the task.</div>
</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Scheduler" href="#dec:type Hopac.Scheduler">Scheduler</a>
</pre>
<div class="nested"><p> Represents a scheduler that manages a number of worker threads.</div>
<pre><b>module</b> <a id="def:module Hopac.Scheduler" href="#dec:module Hopac.Scheduler">Scheduler</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on schedulers.  Use of this module requires more intimate knowledge of Hopac, but may allow adapting Hopac to special application requirements.<pre><b>module</b> <a id="def:module Hopac.Scheduler.Global" href="#dec:module Hopac.Scheduler.Global">Global</a> <b>=</b>
</pre>
<div class="nested"><p> Operations on the global scheduler.<pre><b>val</b> <a id="def:val Hopac.Scheduler.Global.setTopLevelHandler" href="#dec:val Hopac.Scheduler.Global.setTopLevelHandler">setTopLevelHandler</a><b>:</b> option<b>&lt;</b>exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sets the top level exception handler job constructor of the global scheduler.  When a job fails with an otherwise unhandled exception, the job is killed and a new job is constructed with the top level handler constructor and then started.  To avoid infinite loops, in case the top level handler job raises exceptions, it is simply killed after printing a message to the console.  The default top level handler, or <code>None</code>, simply prints out a message to the console.</div>
</div>
<pre><b>type</b> <a id="def:type Hopac.Scheduler.Create" href="#dec:type Hopac.Scheduler.Create">Create</a> <b>=</b>
</pre>
<div class="nested"><p> A record of scheduler configuration options.<pre><a id="def:field Hopac.Scheduler.Create.Foreground" href="#dec:field Hopac.Scheduler.Create.Foreground">Foreground</a><b>:</b> option<b>&lt;</b>bool<b>&gt;</b>
</pre>
<div class="nested"><p> Specifies whether worker threads are run as background threads or as foreground threads.  The default is to run workers as background threads.  If you want to run worker threads as foreground threads, then you will have to explicitly kill the worker threads.  Using foreground threads is probably preferable if your application dynamically creates and kills local schedulers to make sure the worker threads are properly killed.</div>
<pre><a id="def:field Hopac.Scheduler.Create.IdleHandler" href="#dec:field Hopac.Scheduler.Create.IdleHandler">IdleHandler</a><b>:</b> option<b>&lt;</b><a href="#def:type Hopac.Job">Job</a><b>&lt;</b>int<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Specifies the idle handler for workers.  The worker idle handler is run whenever an individual worker runs out of work.  The idle handler must return an integer value that specifies how many milliseconds the worker is allowed to sleep.  <code>Timeout<b>.</b>Infinite</code> puts the worker into sleep until the scheduler explicitly wakes it up.  <code>0</code> means that the idle handler found some new work and the worker should immediately look for it.</div>
<pre><a id="def:field Hopac.Scheduler.Create.MaxStackSize" href="#dec:field Hopac.Scheduler.Create.MaxStackSize">MaxStackSize</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
</pre>
<div class="nested"><p> Specifies the maximum stack size for worker threads.  The default is to use the default maximum stack size of the <code>Thread</code> class.</div>
<pre><a id="def:field Hopac.Scheduler.Create.NumWorkers" href="#dec:field Hopac.Scheduler.Create.NumWorkers">NumWorkers</a><b>:</b> option<b>&lt;</b>int<b>&gt;</b>
</pre>
<div class="nested"><p> Number of worker threads.  Using more than <code>Environment<b>.</b>ProcessorCount</code> is not optimal and may, in some cases, significantly reduce performance.  The default is <code>Environment<b>.</b>ProcessorCount</code>.</div>
<pre><a id="def:field Hopac.Scheduler.Create.Priority" href="#dec:field Hopac.Scheduler.Create.Priority">Priority</a><b>:</b> option<b>&lt;</b>Threading<b>.</b>ThreadPriority<b>&gt;</b>
</pre>
<div class="nested"><p> Specifies the priority of the worker threads.  The default is to use <code>Normal</code> priority.</div>
<pre><a id="def:field Hopac.Scheduler.Create.TopLevelHandler" href="#dec:field Hopac.Scheduler.Create.TopLevelHandler">TopLevelHandler</a><b>:</b> option<b>&lt;</b>exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Specifies the top level exception handler job constructor of the scheduler.  When a job fails with an otherwise unhandled exception, the job is killed and a new job is constructed with the top level handler constructor and then started.  To avoid infinite loops, in case the top level handler job raises exceptions, it is simply killed after printing a message to the console.  The default top level handler simply prints out a message to the console.</div>
<pre><b>static</b> <b>member</b> <a id="def:static member Hopac.Scheduler.Create.Def" href="#dec:static member Hopac.Scheduler.Create.Def">Def</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a>
</pre>
<div class="nested"><p> Default options.</div>
</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.create" href="#dec:val Hopac.Scheduler.create">create</a><b>:</b> <a href="#def:type Hopac.Scheduler.Create">Create</a> <b>-&gt;</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
</pre>
<div class="nested"><p> Creates a new local scheduler.</p><p> Note that a local scheduler does not automatically implement services such as the global wall-clock timer.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.startWithActions" href="#dec:val Hopac.Scheduler.startWithActions">startWithActions</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a>
                   <b>-&gt;</b> (exn <b>-&gt;</b> unit)
                   <b>-&gt;</b> (<i>'x</i> <b>-&gt;</b> unit)
                   <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job, but does not wait for the job to finish. Upon the failure or success of the job, one of the given actions is called once.  See also: <code><a href="#def:val Hopac.Job.abort">abort</a></code>.</p><p> Note that using this function in a job workflow is not optimal and you should instead use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> with desired Job exception handling construct (e.g. <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.tryIn">tryIn</a></code> or <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.catch">catch</a></code>).</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.start" href="#dec:val Hopac.Scheduler.start">start</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>_<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Starts running the given job, but does not wait for the job to finish. The result, if any, of the job is ignored.</p><p> Note that using this function in a job workflow is not optimal and you should use <code><a href="#def:module Hopac.Job">Job</a><b>.</b><a href="#def:val Hopac.Job.start">start</a></code> instead.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.server" href="#dec:val Hopac.Scheduler.server">server</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b><a href="#def:type Hopac.Void">Void</a><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Like <code><a href="#def:module Hopac.Scheduler">Scheduler</a><b>.</b><a href="#def:val Hopac.Scheduler.start">start</a></code>, but the given job is known never to return normally, so the job can be spawned in an even more lightweight manner.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.wait" href="#dec:val Hopac.Scheduler.wait">wait</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Waits until the scheduler becomes completely idle.</p><p> Note that for this to make sense, the scheduler should be a local scheduler that your program manages explicitly.</div>
<pre><b>val</b> <a id="def:val Hopac.Scheduler.kill" href="#dec:val Hopac.Scheduler.kill">kill</a><b>:</b> <a href="#def:type Hopac.Scheduler">Scheduler</a> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Kills the worker threads of the scheduler one-by-one.  This should only be used with a local scheduler that is known to be idle.</div>
</div>
<pre><b>module</b> <a id="def:module Hopac.Infixes" href="#dec:module Hopac.Infixes">Infixes</a> <b>=</b>
</pre>
<div class="nested"><p> Additional infix operators.  You can open this module to bring all of the infix operators into scope.<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-?" href="#dec:val Hopac.Infixes.&lt;-?">&lt;-?</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Alt">Alt</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available for picking when another job offers to take the value.  <code>xCh&nbsp;<a href="#def:val Hopac.Infixes.&lt;-?"><-?</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:module Hopac.Ch.Alt">Alt</a><b>.</b><a href="#def:val Hopac.Ch.Alt.give">give</a>&nbsp;xCh&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;--" href="#dec:val Hopac.Infixes.&lt;--">&lt;--</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that offers to give the given value to another job on the given channel.  A give operation is synchronous.  In other words, a give operation waits until another job takes the value.  <code>xCh&nbsp;<a href="#def:val Hopac.Infixes.&lt;--"><--</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.give">give</a>&nbsp;xCh&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-+" href="#dec:val Hopac.Infixes.&lt;-+">&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Ch">Ch</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends a value to another job on the given channel.  A send operation is asynchronous.  In other words, a send operation does not wait for another job to give the value to.  <code>xCh&nbsp;<a href="#def:val Hopac.Infixes.&lt;-+"><-+</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Ch">Ch</a><b>.</b><a href="#def:val Hopac.Ch.send">send</a>&nbsp;xCh&nbsp;x</code>.</p><p> Note that channels have been optimized for synchronous operations; an occasional send can be efficient, but when sends are queued, performance maybe be significantly worse than with a <code><a href="#def:type Hopac.Mailbox">Mailbox</a></code> optimized for buffering.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-=" href="#dec:val Hopac.Infixes.&lt;-=">&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code>xI&nbsp;<a href="#def:val Hopac.Infixes.&lt;-="><-=</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:val Hopac.IVar.fill">fill</a>&nbsp;xI&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;-=!" href="#dec:val Hopac.Infixes.&lt;-=!">&lt;-=!</a>)<b>:</b> <a href="#def:type Hopac.IVar">IVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> exn <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given exception to the given write once variable.  It is an error to write to a single <code><a href="#def:type Hopac.IVar">IVar</a></code> more than once. This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code>xI&nbsp;<a href="#def:val Hopac.Infixes.&lt;-=!"><-=!</a>&nbsp;e</code> is equivalent to <code><a href="#def:module Hopac.IVar">IVar</a><b>.</b><a href="#def:val Hopac.IVar.fillFailure">fillFailure</a>&nbsp;xI&nbsp;e</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;&lt;-=" href="#dec:val Hopac.Infixes.&lt;&lt;-=">&lt;&lt;-=</a>)<b>:</b> <a href="#def:type Hopac.MVar">MVar</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that writes the given value to the serialized variable.  It is an error to write to a <code><a href="#def:type Hopac.MVar">MVar</a></code> that is full.  This assumption may be used to optimize the implementation and incorrect usage leads to undefined behavior.  <code>xM&nbsp;<a href="#def:val Hopac.Infixes.&lt;&lt;-="><<-=</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.MVar">MVar</a><b>.</b><a href="#def:val Hopac.MVar.fill">fill</a>&nbsp;xM&nbsp;x</code>.</div>
<pre><b>val</b> (<a id="def:val Hopac.Infixes.&lt;&lt;-+" href="#dec:val Hopac.Infixes.&lt;&lt;-+">&lt;&lt;-+</a>)<b>:</b> <a href="#def:type Hopac.Mailbox">Mailbox</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Hopac.Job">Job</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Creates a job that sends the given value to the specified mailbox.  This operation never blocks.  <code>xMb&nbsp;<a href="#def:val Hopac.Infixes.&lt;&lt;-+"><<-+</a>&nbsp;x</code> is equivalent to <code><a href="#def:module Hopac.Mailbox">Mailbox</a><b>.</b><a href="#def:val Hopac.Mailbox.send">send</a>&nbsp;xMb&nbsp;x</code>.</div>
</div>
</div>
</td></tr></table></body>
</html>
